{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound... SharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the samr named pipe (this is similar to opening a file with that name) Bind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB Interact using the Security Account Manager (SAM) Remote Protocol The SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias Close and logoff.. SAMR otherwise returns domain users from the ntds.dit database instead of local users... Faced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method... List all OUs that have a GPO linked (gpLink attribute in LDAP) Skip gpLink that contains no computer object, or are disabled Process the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored) Search for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath Filter for SID we’re interested in: Administrators (S-1-5-32-544…..) Remote Desktop Users (S-1-5-32-555…..) Remote Management Users (S-1-5-32-580…..) Distributed COM Users (S-1-5-32-562…..) Resolve what domain users belong to these groups and which computers these GPOs are applied to... The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all... By default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover user rights enumeration through SAMR and GPOLocalGroup. Further articles in this series:\n\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum (to be published May 12th)\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nUser Rights Enumeration\n\nInformation that proves to be useful during penetration tests is “Which domain user has what permissions on what system?”.\n\nSharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:\n\nAdminTo (members of the local Administrators group)\nCanRDP (members of Remote Desktop Users group)\nCanPSRemote (members of Distributed COM Users group)\nExecuteDCOM (members of Remote Management Users group)\n\nTwo methods to acquire this data are covered in this blog post:\n\nSAMR\nGPOLocalGroup\nSAMR\n\nWhen using the LocalAdmin, RDP, DCOM or PSRemote collection methods, SharpHound enumerates memberships of local groups (their users and permissions) on the target systems by querying the Windows SAM database remotely.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\samr, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Security Account Manager (SAM) Remote Protocol (RPC over SMB on port 445).\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound SAMR call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the samr named pipe (this is similar to opening a file with that name)\nBind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB\nInteract using the Security Account Manager (SAM) Remote Protocol\nThe SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the samr named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows, as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (samr)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nResult filtering\n\nWindows comes with default accounts that we are not interested in. SharpHound filters out the following from the final result:\n\nLocal user accounts\nLocal service accounts (S-1-5-80)\nIIS AppPool identities (S-1-5-82)\nWindow Manager accounts (DWM) (S-1-5-90)\nFont Driver Host accounts (S-1-5-96)\nWhat privileges are required?\n\nThere was a time where all authenticated users could access the SAM information for any computer in the domain. This allowed to get all domain and local users assigned to a local group on the machine. Starting with Windows 10 1607+ and Windows Server 2016+, the default configuration has changed and SAMR is now restricted to the members of the local built-in Administrators group.\n\nThe presence of older OS in an environment doesn’t necessarily mean that it is possible to enumerate local group membership, since Microsoft provided an optional update down to Windows 7 and Server 2008 R2 to allow control over this behavior. The following GPO can be configured to harden these older versions:\n\nComputer Configuration|Windows Settings|Security Settings|Local Policies|Security Options|Network access: Restrict clients allowed to make remote calls to SAM\n\n\n\nThis same GPO also allows to reopen access to SAMR for non-admin users!\n\nBefore this change, you might have stumbled upon a PowerShell script by Itai Grady named “SAMRi10”, which had a similar purpose.\n\nExceptions\n\nSome systems are not affected by this restriction: Domain Controllers (DC) and Read-Only Domain Controllers (RODC). All authenticated users still have access to SAMR on such systems to preserve compatibility.\n\nUnfortunately (for us pentesters) this is not really helpful because the local SAM database of a DC isn’t normally used. Why? The SAM database is present (you can verify it with mimikatz lsadump::sam), but it is only used when booting into Directory Services Repair Mode (DSRM) or the Recovery Console.\n\nSAMR otherwise returns domain users from the ntds.dit database instead of local users. This is what happens when issuing the net user /domain command.\n\nFurther reading\n\nTechnical information about the Security Account Manager (SAM) Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380\n\nSharpHound implements SAMR in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/SAMRPCServer.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nThe SAMR RPC calls themselves for all four types of edges are made from this code via GetLocalGroupMembers: \nhttps://github.com/BloodHoundAD/SharpHound/blob/dev/src/Runtime/ObjectProcessors.cs\n\nGPOLocalGroup\n\nFaced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method.\n\nHow does it work?\n\nGroup Policy Objects (GPOs) can be used to manage local groups on computers. This can be done in two different ways and both are collected by SharpHound:\n\nLocal Users and Groups Group Policy Preferences (GPP) found at Computer Configuration\\Preferences\\Control Panel Settings\\(Despite the fact that this can also be managed in User Configuration, SharpHound will only look at the Computer Configuration part)\nRestricted Groups found at Computer Configuration\\Policies\\Windows Settings\\Security Settings\\\nImplementation details\n\nThe data collection goes as follows:\n\nList all OUs that have a GPO linked (gpLink attribute in LDAP)\nSkip gpLink that contains no computer object, or are disabled\nProcess the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored)\nSearch for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath\nFilter for SID we’re interested in:\nAdministrators (S-1-5-32-544…..)\nRemote Desktop Users (S-1-5-32-555…..)\nRemote Management Users (S-1-5-32-580…..)\nDistributed COM Users (S-1-5-32-562…..)\nResolve what domain users belong to these groups and which computers these GPOs are applied to.\n\nThere is more going on that we won’t explain in detail here. In short: there might be conflicts since both methods could be used simultaneously with different or overlapping membership entries. Users can be deleted, added, updated. Additionally, Restricted Groups have precedence over GPP settings and override them. SharpHound will make sure that everything is taken care of and will return the resultant configuration.\n\nLimitations\n\nFirst and foremost, this collection method will not retrieve group memberships added locally (hence the advantage of the SAMR collection method). The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all.\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nGet all objects in the domain through LDAP (not all requests are shown above)\nEstablish a SMB connection to the DC (Kerberos authentication)\nConnect to the SYSVOL share and look for the XML files\nClose and logoff\n\nAuthorization is performed at two different places in this trace:\n\nWhen querying data through LDAP\nWhen attempting to open the SYSVOL share and the XML files\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (ldap)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nBy default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers. However the Security Filtering of a GPO can be edited to restrict read access:\n\nIf the GPO is only readable by computer objects where they apply, access to the policies on SYSVOL will be denied and SharpHound will be blind.\n\nFurther reading\n\nSharpHound implements “GPOLocalGroup” in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/GPOLocalGroupProcessor.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 1: User Rights Enumeration Through SAMR & GPOLocalGroup"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound... SharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the samr named pipe (this is similar to opening a file with that name) Bind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB Interact using the Security Account Manager (SAM) Remote Protocol The SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias Close and logoff.. SAMR otherwise returns domain users from the ntds.dit database instead of local users... Faced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method... List all OUs that have a GPO linked (gpLink attribute in LDAP) Skip gpLink that contains no computer object, or are disabled Process the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored) Search for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath Filter for SID we’re interested in: Administrators (S-1-5-32-544…..) Remote Desktop Users (S-1-5-32-555…..) Remote Management Users (S-1-5-32-580…..) Distributed COM Users (S-1-5-32-562…..) Resolve what domain users belong to these groups and which computers these GPOs are applied to... The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all... By default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover user rights enumeration through SAMR and GPOLocalGroup. Further articles in this series:\n\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum (to be published May 12th)\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nUser Rights Enumeration\n\nInformation that proves to be useful during penetration tests is “Which domain user has what permissions on what system?”.\n\nSharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:\n\nAdminTo (members of the local Administrators group)\nCanRDP (members of Remote Desktop Users group)\nCanPSRemote (members of Distributed COM Users group)\nExecuteDCOM (members of Remote Management Users group)\n\nTwo methods to acquire this data are covered in this blog post:\n\nSAMR\nGPOLocalGroup\nSAMR\n\nWhen using the LocalAdmin, RDP, DCOM or PSRemote collection methods, SharpHound enumerates memberships of local groups (their users and permissions) on the target systems by querying the Windows SAM database remotely.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\samr, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Security Account Manager (SAM) Remote Protocol (RPC over SMB on port 445).\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound SAMR call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the samr named pipe (this is similar to opening a file with that name)\nBind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB\nInteract using the Security Account Manager (SAM) Remote Protocol\nThe SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the samr named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows, as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (samr)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nResult filtering\n\nWindows comes with default accounts that we are not interested in. SharpHound filters out the following from the final result:\n\nLocal user accounts\nLocal service accounts (S-1-5-80)\nIIS AppPool identities (S-1-5-82)\nWindow Manager accounts (DWM) (S-1-5-90)\nFont Driver Host accounts (S-1-5-96)\nWhat privileges are required?\n\nThere was a time where all authenticated users could access the SAM information for any computer in the domain. This allowed to get all domain and local users assigned to a local group on the machine. Starting with Windows 10 1607+ and Windows Server 2016+, the default configuration has changed and SAMR is now restricted to the members of the local built-in Administrators group.\n\nThe presence of older OS in an environment doesn’t necessarily mean that it is possible to enumerate local group membership, since Microsoft provided an optional update down to Windows 7 and Server 2008 R2 to allow control over this behavior. The following GPO can be configured to harden these older versions:\n\nComputer Configuration|Windows Settings|Security Settings|Local Policies|Security Options|Network access: Restrict clients allowed to make remote calls to SAM\n\n\n\nThis same GPO also allows to reopen access to SAMR for non-admin users!\n\nBefore this change, you might have stumbled upon a PowerShell script by Itai Grady named “SAMRi10”, which had a similar purpose.\n\nExceptions\n\nSome systems are not affected by this restriction: Domain Controllers (DC) and Read-Only Domain Controllers (RODC). All authenticated users still have access to SAMR on such systems to preserve compatibility.\n\nUnfortunately (for us pentesters) this is not really helpful because the local SAM database of a DC isn’t normally used. Why? The SAM database is present (you can verify it with mimikatz lsadump::sam), but it is only used when booting into Directory Services Repair Mode (DSRM) or the Recovery Console.\n\nSAMR otherwise returns domain users from the ntds.dit database instead of local users. This is what happens when issuing the net user /domain command.\n\nFurther reading\n\nTechnical information about the Security Account Manager (SAM) Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380\n\nSharpHound implements SAMR in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/SAMRPCServer.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nThe SAMR RPC calls themselves for all four types of edges are made from this code via GetLocalGroupMembers: \nhttps://github.com/BloodHoundAD/SharpHound/blob/dev/src/Runtime/ObjectProcessors.cs\n\nGPOLocalGroup\n\nFaced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method.\n\nHow does it work?\n\nGroup Policy Objects (GPOs) can be used to manage local groups on computers. This can be done in two different ways and both are collected by SharpHound:\n\nLocal Users and Groups Group Policy Preferences (GPP) found at Computer Configuration\\Preferences\\Control Panel Settings\\(Despite the fact that this can also be managed in User Configuration, SharpHound will only look at the Computer Configuration part)\nRestricted Groups found at Computer Configuration\\Policies\\Windows Settings\\Security Settings\\\nImplementation details\n\nThe data collection goes as follows:\n\nList all OUs that have a GPO linked (gpLink attribute in LDAP)\nSkip gpLink that contains no computer object, or are disabled\nProcess the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored)\nSearch for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath\nFilter for SID we’re interested in:\nAdministrators (S-1-5-32-544…..)\nRemote Desktop Users (S-1-5-32-555…..)\nRemote Management Users (S-1-5-32-580…..)\nDistributed COM Users (S-1-5-32-562…..)\nResolve what domain users belong to these groups and which computers these GPOs are applied to.\n\nThere is more going on that we won’t explain in detail here. In short: there might be conflicts since both methods could be used simultaneously with different or overlapping membership entries. Users can be deleted, added, updated. Additionally, Restricted Groups have precedence over GPP settings and override them. SharpHound will make sure that everything is taken care of and will return the resultant configuration.\n\nLimitations\n\nFirst and foremost, this collection method will not retrieve group memberships added locally (hence the advantage of the SAMR collection method). The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all.\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nGet all objects in the domain through LDAP (not all requests are shown above)\nEstablish a SMB connection to the DC (Kerberos authentication)\nConnect to the SYSVOL share and look for the XML files\nClose and logoff\n\nAuthorization is performed at two different places in this trace:\n\nWhen querying data through LDAP\nWhen attempting to open the SYSVOL share and the XML files\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (ldap)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nBy default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers. However the Security Filtering of a GPO can be edited to restrict read access:\n\nIf the GPO is only readable by computer objects where they apply, access to the policies on SYSVOL will be denied and SharpHound will be blind.\n\nFurther reading\n\nSharpHound implements “GPOLocalGroup” in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/GPOLocalGroupProcessor.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 1: User Rights Enumeration Through SAMR & GPOLocalGroup"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound... SharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the samr named pipe (this is similar to opening a file with that name) Bind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB Interact using the Security Account Manager (SAM) Remote Protocol The SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias Close and logoff.. SAMR otherwise returns domain users from the ntds.dit database instead of local users... Faced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method... List all OUs that have a GPO linked (gpLink attribute in LDAP) Skip gpLink that contains no computer object, or are disabled Process the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored) Search for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath Filter for SID we’re interested in: Administrators (S-1-5-32-544…..) Remote Desktop Users (S-1-5-32-555…..) Remote Management Users (S-1-5-32-580…..) Distributed COM Users (S-1-5-32-562…..) Resolve what domain users belong to these groups and which computers these GPOs are applied to... The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all... By default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover user rights enumeration through SAMR and GPOLocalGroup. Further articles in this series:\n\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum (to be published May 12th)\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nUser Rights Enumeration\n\nInformation that proves to be useful during penetration tests is “Which domain user has what permissions on what system?”.\n\nSharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:\n\nAdminTo (members of the local Administrators group)\nCanRDP (members of Remote Desktop Users group)\nCanPSRemote (members of Distributed COM Users group)\nExecuteDCOM (members of Remote Management Users group)\n\nTwo methods to acquire this data are covered in this blog post:\n\nSAMR\nGPOLocalGroup\nSAMR\n\nWhen using the LocalAdmin, RDP, DCOM or PSRemote collection methods, SharpHound enumerates memberships of local groups (their users and permissions) on the target systems by querying the Windows SAM database remotely.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\samr, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Security Account Manager (SAM) Remote Protocol (RPC over SMB on port 445).\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound SAMR call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the samr named pipe (this is similar to opening a file with that name)\nBind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB\nInteract using the Security Account Manager (SAM) Remote Protocol\nThe SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the samr named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows, as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (samr)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nResult filtering\n\nWindows comes with default accounts that we are not interested in. SharpHound filters out the following from the final result:\n\nLocal user accounts\nLocal service accounts (S-1-5-80)\nIIS AppPool identities (S-1-5-82)\nWindow Manager accounts (DWM) (S-1-5-90)\nFont Driver Host accounts (S-1-5-96)\nWhat privileges are required?\n\nThere was a time where all authenticated users could access the SAM information for any computer in the domain. This allowed to get all domain and local users assigned to a local group on the machine. Starting with Windows 10 1607+ and Windows Server 2016+, the default configuration has changed and SAMR is now restricted to the members of the local built-in Administrators group.\n\nThe presence of older OS in an environment doesn’t necessarily mean that it is possible to enumerate local group membership, since Microsoft provided an optional update down to Windows 7 and Server 2008 R2 to allow control over this behavior. The following GPO can be configured to harden these older versions:\n\nComputer Configuration|Windows Settings|Security Settings|Local Policies|Security Options|Network access: Restrict clients allowed to make remote calls to SAM\n\n\n\nThis same GPO also allows to reopen access to SAMR for non-admin users!\n\nBefore this change, you might have stumbled upon a PowerShell script by Itai Grady named “SAMRi10”, which had a similar purpose.\n\nExceptions\n\nSome systems are not affected by this restriction: Domain Controllers (DC) and Read-Only Domain Controllers (RODC). All authenticated users still have access to SAMR on such systems to preserve compatibility.\n\nUnfortunately (for us pentesters) this is not really helpful because the local SAM database of a DC isn’t normally used. Why? The SAM database is present (you can verify it with mimikatz lsadump::sam), but it is only used when booting into Directory Services Repair Mode (DSRM) or the Recovery Console.\n\nSAMR otherwise returns domain users from the ntds.dit database instead of local users. This is what happens when issuing the net user /domain command.\n\nFurther reading\n\nTechnical information about the Security Account Manager (SAM) Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380\n\nSharpHound implements SAMR in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/SAMRPCServer.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nThe SAMR RPC calls themselves for all four types of edges are made from this code via GetLocalGroupMembers: \nhttps://github.com/BloodHoundAD/SharpHound/blob/dev/src/Runtime/ObjectProcessors.cs\n\nGPOLocalGroup\n\nFaced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method.\n\nHow does it work?\n\nGroup Policy Objects (GPOs) can be used to manage local groups on computers. This can be done in two different ways and both are collected by SharpHound:\n\nLocal Users and Groups Group Policy Preferences (GPP) found at Computer Configuration\\Preferences\\Control Panel Settings\\(Despite the fact that this can also be managed in User Configuration, SharpHound will only look at the Computer Configuration part)\nRestricted Groups found at Computer Configuration\\Policies\\Windows Settings\\Security Settings\\\nImplementation details\n\nThe data collection goes as follows:\n\nList all OUs that have a GPO linked (gpLink attribute in LDAP)\nSkip gpLink that contains no computer object, or are disabled\nProcess the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored)\nSearch for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath\nFilter for SID we’re interested in:\nAdministrators (S-1-5-32-544…..)\nRemote Desktop Users (S-1-5-32-555…..)\nRemote Management Users (S-1-5-32-580…..)\nDistributed COM Users (S-1-5-32-562…..)\nResolve what domain users belong to these groups and which computers these GPOs are applied to.\n\nThere is more going on that we won’t explain in detail here. In short: there might be conflicts since both methods could be used simultaneously with different or overlapping membership entries. Users can be deleted, added, updated. Additionally, Restricted Groups have precedence over GPP settings and override them. SharpHound will make sure that everything is taken care of and will return the resultant configuration.\n\nLimitations\n\nFirst and foremost, this collection method will not retrieve group memberships added locally (hence the advantage of the SAMR collection method). The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all.\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nGet all objects in the domain through LDAP (not all requests are shown above)\nEstablish a SMB connection to the DC (Kerberos authentication)\nConnect to the SYSVOL share and look for the XML files\nClose and logoff\n\nAuthorization is performed at two different places in this trace:\n\nWhen querying data through LDAP\nWhen attempting to open the SYSVOL share and the XML files\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (ldap)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nBy default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers. However the Security Filtering of a GPO can be edited to restrict read access:\n\nIf the GPO is only readable by computer objects where they apply, access to the policies on SYSVOL will be denied and SharpHound will be blind.\n\nFurther reading\n\nSharpHound implements “GPOLocalGroup” in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/GPOLocalGroupProcessor.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 1: User Rights Enumeration Through SAMR & GPOLocalGroup"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound... SharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the samr named pipe (this is similar to opening a file with that name) Bind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB Interact using the Security Account Manager (SAM) Remote Protocol The SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias Close and logoff.. SAMR otherwise returns domain users from the ntds.dit database instead of local users... Faced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method... List all OUs that have a GPO linked (gpLink attribute in LDAP) Skip gpLink that contains no computer object, or are disabled Process the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored) Search for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath Filter for SID we’re interested in: Administrators (S-1-5-32-544…..) Remote Desktop Users (S-1-5-32-555…..) Remote Management Users (S-1-5-32-580…..) Distributed COM Users (S-1-5-32-562…..) Resolve what domain users belong to these groups and which computers these GPOs are applied to... The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all... By default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover user rights enumeration through SAMR and GPOLocalGroup. Further articles in this series:\n\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum (to be published May 12th)\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nUser Rights Enumeration\n\nInformation that proves to be useful during penetration tests is “Which domain user has what permissions on what system?”.\n\nSharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:\n\nAdminTo (members of the local Administrators group)\nCanRDP (members of Remote Desktop Users group)\nCanPSRemote (members of Distributed COM Users group)\nExecuteDCOM (members of Remote Management Users group)\n\nTwo methods to acquire this data are covered in this blog post:\n\nSAMR\nGPOLocalGroup\nSAMR\n\nWhen using the LocalAdmin, RDP, DCOM or PSRemote collection methods, SharpHound enumerates memberships of local groups (their users and permissions) on the target systems by querying the Windows SAM database remotely.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\samr, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Security Account Manager (SAM) Remote Protocol (RPC over SMB on port 445).\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound SAMR call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the samr named pipe (this is similar to opening a file with that name)\nBind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB\nInteract using the Security Account Manager (SAM) Remote Protocol\nThe SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the samr named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows, as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (samr)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nResult filtering\n\nWindows comes with default accounts that we are not interested in. SharpHound filters out the following from the final result:\n\nLocal user accounts\nLocal service accounts (S-1-5-80)\nIIS AppPool identities (S-1-5-82)\nWindow Manager accounts (DWM) (S-1-5-90)\nFont Driver Host accounts (S-1-5-96)\nWhat privileges are required?\n\nThere was a time where all authenticated users could access the SAM information for any computer in the domain. This allowed to get all domain and local users assigned to a local group on the machine. Starting with Windows 10 1607+ and Windows Server 2016+, the default configuration has changed and SAMR is now restricted to the members of the local built-in Administrators group.\n\nThe presence of older OS in an environment doesn’t necessarily mean that it is possible to enumerate local group membership, since Microsoft provided an optional update down to Windows 7 and Server 2008 R2 to allow control over this behavior. The following GPO can be configured to harden these older versions:\n\nComputer Configuration|Windows Settings|Security Settings|Local Policies|Security Options|Network access: Restrict clients allowed to make remote calls to SAM\n\n\n\nThis same GPO also allows to reopen access to SAMR for non-admin users!\n\nBefore this change, you might have stumbled upon a PowerShell script by Itai Grady named “SAMRi10”, which had a similar purpose.\n\nExceptions\n\nSome systems are not affected by this restriction: Domain Controllers (DC) and Read-Only Domain Controllers (RODC). All authenticated users still have access to SAMR on such systems to preserve compatibility.\n\nUnfortunately (for us pentesters) this is not really helpful because the local SAM database of a DC isn’t normally used. Why? The SAM database is present (you can verify it with mimikatz lsadump::sam), but it is only used when booting into Directory Services Repair Mode (DSRM) or the Recovery Console.\n\nSAMR otherwise returns domain users from the ntds.dit database instead of local users. This is what happens when issuing the net user /domain command.\n\nFurther reading\n\nTechnical information about the Security Account Manager (SAM) Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380\n\nSharpHound implements SAMR in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/SAMRPCServer.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nThe SAMR RPC calls themselves for all four types of edges are made from this code via GetLocalGroupMembers: \nhttps://github.com/BloodHoundAD/SharpHound/blob/dev/src/Runtime/ObjectProcessors.cs\n\nGPOLocalGroup\n\nFaced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method.\n\nHow does it work?\n\nGroup Policy Objects (GPOs) can be used to manage local groups on computers. This can be done in two different ways and both are collected by SharpHound:\n\nLocal Users and Groups Group Policy Preferences (GPP) found at Computer Configuration\\Preferences\\Control Panel Settings\\(Despite the fact that this can also be managed in User Configuration, SharpHound will only look at the Computer Configuration part)\nRestricted Groups found at Computer Configuration\\Policies\\Windows Settings\\Security Settings\\\nImplementation details\n\nThe data collection goes as follows:\n\nList all OUs that have a GPO linked (gpLink attribute in LDAP)\nSkip gpLink that contains no computer object, or are disabled\nProcess the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored)\nSearch for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath\nFilter for SID we’re interested in:\nAdministrators (S-1-5-32-544…..)\nRemote Desktop Users (S-1-5-32-555…..)\nRemote Management Users (S-1-5-32-580…..)\nDistributed COM Users (S-1-5-32-562…..)\nResolve what domain users belong to these groups and which computers these GPOs are applied to.\n\nThere is more going on that we won’t explain in detail here. In short: there might be conflicts since both methods could be used simultaneously with different or overlapping membership entries. Users can be deleted, added, updated. Additionally, Restricted Groups have precedence over GPP settings and override them. SharpHound will make sure that everything is taken care of and will return the resultant configuration.\n\nLimitations\n\nFirst and foremost, this collection method will not retrieve group memberships added locally (hence the advantage of the SAMR collection method). The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all.\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nGet all objects in the domain through LDAP (not all requests are shown above)\nEstablish a SMB connection to the DC (Kerberos authentication)\nConnect to the SYSVOL share and look for the XML files\nClose and logoff\n\nAuthorization is performed at two different places in this trace:\n\nWhen querying data through LDAP\nWhen attempting to open the SYSVOL share and the XML files\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (ldap)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nBy default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers. However the Security Filtering of a GPO can be edited to restrict read access:\n\nIf the GPO is only readable by computer objects where they apply, access to the policies on SYSVOL will be denied and SharpHound will be blind.\n\nFurther reading\n\nSharpHound implements “GPOLocalGroup” in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/GPOLocalGroupProcessor.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 1: User Rights Enumeration Through SAMR & GPOLocalGroup"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the wkssvc named pipe (this is similar to opening a file with that name) Bind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB Interact using the Workstation Service Remote Protocol, call NetWkstaUserEnum Close and logoff.. SharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs... NetSessionEnum.. When using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function... In the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating... The session from user “Administrator” is actually made by NetSess.exe itself!.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the srvsvc named pipe (this is similar to opening a file with that name) Bind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188 Interact using the Server Service Remote Protocol to query NetSessionEnum Close and logoff.. The permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity... to:.. What stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation... The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:..",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through NetWkstaUserEnum & NetSessionEnum. Further articles in this series:\n\nUser Rights Enumeration Through SAMR and GPOLocalGroup\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nSession Enumeration\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe will cover the two first in this post and the last one in the next blog post.\n\nNetWkstaUserEnum\n\nWhen using the LoggedOn collection method, SharpHound enumerates logged on users by using the NetWkstaUserEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\wkssvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Workstation Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nTo show the information returned by this function, we can use the NetWkstaUserEnum.ps1 PowerShell script by Will Schroeder:\n\nThe function lists all (interactive, service and batch) logons, their logon domains and logon servers.\n\nResults filtering\n\nSome of the entries in the above screenshot are not useful to us. SharpHound is filtering out the following:\n\nLocal user accounts\nEmpty usernames and computer sessions\nEntries without a logon domain\nAny logon domain containing a whitespace (to ignore “NT Authority” and similar)\n\nIn our example above, only two entries would be kept by SharpHound:\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the wkssvc named pipe (this is similar to opening a file with that name)\nBind to the wkssvc interface with UUID 6BFFD098-A112-3610-9833-46C3F87E345A using RPC over SMB\nInteract using the Workstation Service Remote Protocol, call NetWkstaUserEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the wkssvc pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (wkssvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nOnly an administrator can successfully use the NetWkstaUserEnum function or as stated by Microsoft:\n\nMembers of the Administrators, and the Server, System and Print Operator local groups can also view information\n\nHence, this method will not be of help in most cases but if you have admin credentials, it is the most reliable way of listing logged-on users.\n\nFurther reading\n\nMore details on the “NetWkstaUserEnum” function: https://docs.microsoft.com/en-us/windows/win32/api/lmwksta/nf-lmwksta-netwkstauserenum\n\nMore detailed and technical information about the Workstation Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wkst/5bb08058-bc36-4d3c-abeb-b132228281b7\n\nSharpHound implements “NetWkstaUserEnum” in “ReadUserSessionsPrivileged” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nNetSessionEnum\n\nWhen using the Session collection method, SharpHound enumerates logged on users by using the NetSessionEnum function.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\srvsvc, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Server Service Remote Protocol (RPC over SMB on port 445).\n\nImplementation details\n\nWe mentioned “logged on users” above. This is actually not accurate and a simplification. In reality NetSessionEnum provides information about who has a session established to the system and from where.\n\nSo how does BloodHound come up with the correct data in the Graph? Let’s first see a successful example of a NetSessionEnum query. For this we can use several tools:\n\nPsLoggedOn from Sysinternals,\nNetSess from Joeware.net,\nInvoke-NetSessionEnum.ps1 from Fuzzy Security\n\nIn the screenshot above, we see two user accounts which have a session to the target host as well as from which IP the connection is originating. The session from user “Administrator” is actually made by NetSess.exe itself!\n\nBy collecting this data from different systems and resolving IP addresses to hostnames, SharpHound is clever enough to correlate sessions to hosts.\n\nResult filtering\n\nAgain, some of the entries in the above screenshot are not useful to us. SharpHound filters the following out:\n\nEntries with blank or null usernames\nEntries with blank or null computer/client names\nEntries where computer accounts are connected\nEntries with the user used for enumeration (see below why)\nEntries with anonymous logons\n\nNote: This method will almost never return local accounts since they are usually not allowed to connect via SMB.\n\nFrom our example above, only one entry would be kept by SharpHound:\n\nLimitations\n\nA major disadvantage compared to the other methods is, that this technique does not provide complete results. Think of users who have no connections to scanned systems, since theses don’t use any network resources, they won’t appear through NetSessionEnum.\n\nBy knowing this we can think about what systems make good targets for this method: those that have by design many connections to them. For example file servers, servers hosting user homes or Domain Controllers which hosts scripts that users execute during their logon process. For this reason, it is worth using the Session Loop collection method!\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound NetSessionEnumcall allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the srvsvc named pipe (this is similar to opening a file with that name)\nBind to the srvsvc interface with its UUID 4b324fc8-1670-01d3-1278-5a47bf6ee188\nInteract using the Server Service Remote Protocol to query NetSessionEnum\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the srvsvc named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (srvsvc)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nFun fact\n\nSince NetSessionEnum displays SMB connections it will display a connection for each of the collection methods shown in this serie of articles:\n\nSAMR\nGPOLocalGroup\nNetWkstaUserEnum\nRemote Registry\neven NetSessionEnum itself\nWhat privileges are required?\n\nThis method worked for quite some time with any authenticated user. Unfortunately (for pentesters and attackers) this has changed in recent versions but it is not exactly clear when this change happened, since there is simply no clear public documentation about it from Microsoft. It is rumored to have changed in Windows 10 1607 and Windows Server 2019 but we decided to do our own testing, which is presented below.\n\nBefore these changes found their way into the Windows default settings, there was a PowerShell script written in 2016 by two Microsoft researchers (Itai Grady and Tal Be’ery) named NetCease, that did exactly the same as the new default values do.\n\nThe permissions for who can use NetSessionEnum is defined in the registry value SrvsvcSessionInfo in the hive HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\DefaultSecurity.\n\nThe default persmission set changed from:\n\nAdministrators\nServer Operators\nPower Users\nAuthenticated Users\n\nto:\n\nAdministrators\nServer Operators\nPower Users\nInteractive\nService\nBatch\n\nHence, the function can only be called locally or by high-privileged users. If you want to check it by yourself you can either decode the binary registry value using PowerShell or use NetCease as follows:\n\n# Download the module\nSave-Module -Name NetCease -Repository PSGallery -Path ~/Downloads\n# Load the moduleImport-Module ~/Downloads/NetCease/1.0.3/NetCease.psd1 -Force -Verbose # View current NetSessionEnum permissionsGet-NetSessionEnumPermission | Select TranslatedSID,SecurityIdentifier,AccessMask,AceType | ft -AutoSize\n\nThis will get you the following output:\n\nThe SID S-1-5-32-549 is “BUILTIN\\Server Operators”, this matches the list above.\n\nOS comparison\n\nAs mentioned above, we looked at the permissions on different Windows versions with different configurations. It was also tested after applying all updates (as of October 2021):\n\nOS version\tPatch\nlevel after\ninstallation\tAuthenticated\nusers\nallowed?\tImpact of\npromotion\nto DC?\tPatch level\nafter updates\tImpact of\nsecurity\nupdates?\nWindows 10 1607\t14393.0\tYes\t–\t14393.2214\tNo\nWindows 10 1703\t15063.0\tYes\t–\t15063.1418\tNo\nWindows 10 1709\t16299.15\tNo\t–\t16299.2166\tNo\nWindows 10 21H1\t19043.1165\tNo\t–\t19043.1288\tNo\nWindows Server 2016 (1607)\t14393.693\tYes\tNo\t14393.4704\tNo\nWindows Server 2019 (1809)\t17763.737\tNo\tNo\t17763.2237\tNo\n Windows Server 2022 (21H2)\t\n20348.169\tNo\tNo\t20348.288\tNo\n\nAs we can see, only the “major” Windows version plays a role. This was expected but it is always nice to verify it by yourself!\n\nMisleading documentation\n\nThe Microsoft documentation for NetSessionEnum made understanding the permissions difficult. The function accepts a parameter called level, which decides what information should be returned:\n\nThe level is important, because permissions needed by the user invoking the call depend on it:\n\nSharpHound (and all of the above mentioned tools) use level 10:\n\nThis can also be seen in Wireshark:\n\nAccording to Microsoft no special group membership is needed for level 10. In our opinion, this documentation is simply outdated and does not reflect the changes introduced with NetCease.\n\nLevels and permissions\n\nWe tested Invoke-NetSessionEnum.ps1 against different versions of Windows as a regular authenticated user and checked the result:\n\nOperating System/Level\t0\t1\t2\t10\t502\nWindows 10 1607\t\t\t\t\t\nWindows 10 1703\t\t\t\t\t\nWindows 10 1709\t\t\t\t\t\nWindows 10 21H1\t\t\t\t\t\nWindows Server 2016 (1607)\t\t\t\t\t\nWindows Server 2019 (1809)\t\t\t\t\t\n Windows Server 2022 (21H2)\t\t\t\t\t\n\nWhat stands out is that level 502 needs higher privileges and this is not mentioned on the Microsoft documentation. The technical implementation guide for the Server Service Remote Protocol gives an explanation about permissions for level 502:\n\nThe server SHOULD<51> enforce the security measures to verify that the caller has the required permissions to execute this routine. If the caller does not have the required credentials, the server SHOULD<52> fail the call.\n\nFollowing the reference <52> leads to the answer:\n\n<52> Section 3.1.4.5: If the caller is not a member of the Administrator or Server Operator local group, Windows-based servers fail the call with the error code ERROR_ACCESS_DENIED.\n\nFurther reading\n\nMore details on the “NetSessionEnum” function: https://docs.microsoft.com/de-ch/windows/win32/api/lmshare/nf-lmshare-netsessionenum\n\nMore detailed and technical information about the Server Service Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-srvs/accf23b0-0f57-441c-9185-43041f1b0ee9\n\nSharpHound implements “NetSessionEnum” in ” ReadUserSessions” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 2: Session Enumeration Through NetWkstaUserEnum & NetSessionEnum"
}
{
    "brief": "However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound... SharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:.. Establish an SMB connection to the remote host (Kerberos authentication) Connect to the IPC$ share Open the samr named pipe (this is similar to opening a file with that name) Bind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB Interact using the Security Account Manager (SAM) Remote Protocol The SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias Close and logoff.. SAMR otherwise returns domain users from the ntds.dit database instead of local users... Faced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method... List all OUs that have a GPO linked (gpLink attribute in LDAP) Skip gpLink that contains no computer object, or are disabled Process the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored) Search for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath Filter for SID we’re interested in: Administrators (S-1-5-32-544…..) Remote Desktop Users (S-1-5-32-555…..) Remote Management Users (S-1-5-32-580…..) Distributed COM Users (S-1-5-32-562…..) Resolve what domain users belong to these groups and which computers these GPOs are applied to... The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all... By default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover user rights enumeration through SAMR and GPOLocalGroup. Further articles in this series:\n\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum (to be published May 12th)\nSession Enumeration Through Remote Registry & Summary (to be published May 25th)\nUser Rights Enumeration\n\nInformation that proves to be useful during penetration tests is “Which domain user has what permissions on what system?”.\n\nSharpHound will try to enumerate this information from local group membership and BloodHound displays it with the following edges:\n\nAdminTo (members of the local Administrators group)\nCanRDP (members of Remote Desktop Users group)\nCanPSRemote (members of Distributed COM Users group)\nExecuteDCOM (members of Remote Management Users group)\n\nTwo methods to acquire this data are covered in this blog post:\n\nSAMR\nGPOLocalGroup\nSAMR\n\nWhen using the LocalAdmin, RDP, DCOM or PSRemote collection methods, SharpHound enumerates memberships of local groups (their users and permissions) on the target systems by querying the Windows SAM database remotely.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\samr, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Security Account Manager (SAM) Remote Protocol (RPC over SMB on port 445).\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound SAMR call allows us to highlight the steps involved:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the samr named pipe (this is similar to opening a file with that name)\nBind to the samr interface with its UUID 12345778-1234-abcd-ef00-0123456789ac using RPC over SMB\nInteract using the Security Account Manager (SAM) Remote Protocol\nThe SIDs of users and groups inside of the local group are queried using the function GetMembersInAlias\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the samr named pipe\nWhen we attempt to execute an RPC call via the pipe\n\nThis last part fails with a low-privileged user on newer Windows, as we’ll see below.\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (samr)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nResult filtering\n\nWindows comes with default accounts that we are not interested in. SharpHound filters out the following from the final result:\n\nLocal user accounts\nLocal service accounts (S-1-5-80)\nIIS AppPool identities (S-1-5-82)\nWindow Manager accounts (DWM) (S-1-5-90)\nFont Driver Host accounts (S-1-5-96)\nWhat privileges are required?\n\nThere was a time where all authenticated users could access the SAM information for any computer in the domain. This allowed to get all domain and local users assigned to a local group on the machine. Starting with Windows 10 1607+ and Windows Server 2016+, the default configuration has changed and SAMR is now restricted to the members of the local built-in Administrators group.\n\nThe presence of older OS in an environment doesn’t necessarily mean that it is possible to enumerate local group membership, since Microsoft provided an optional update down to Windows 7 and Server 2008 R2 to allow control over this behavior. The following GPO can be configured to harden these older versions:\n\nComputer Configuration|Windows Settings|Security Settings|Local Policies|Security Options|Network access: Restrict clients allowed to make remote calls to SAM\n\n\n\nThis same GPO also allows to reopen access to SAMR for non-admin users!\n\nBefore this change, you might have stumbled upon a PowerShell script by Itai Grady named “SAMRi10”, which had a similar purpose.\n\nExceptions\n\nSome systems are not affected by this restriction: Domain Controllers (DC) and Read-Only Domain Controllers (RODC). All authenticated users still have access to SAMR on such systems to preserve compatibility.\n\nUnfortunately (for us pentesters) this is not really helpful because the local SAM database of a DC isn’t normally used. Why? The SAM database is present (you can verify it with mimikatz lsadump::sam), but it is only used when booting into Directory Services Repair Mode (DSRM) or the Recovery Console.\n\nSAMR otherwise returns domain users from the ntds.dit database instead of local users. This is what happens when issuing the net user /domain command.\n\nFurther reading\n\nTechnical information about the Security Account Manager (SAM) Remote Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-samr/4df07fab-1bbc-452f-8e92-7853a3c7e380\n\nSharpHound implements SAMR in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/SAMRPCServer.cs and the code relies on native Windows functions to which the P/Invoke signatures are declared in: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/NativeMethods.cs.\n\nThe SAMR RPC calls themselves for all four types of edges are made from this code via GetLocalGroupMembers: \nhttps://github.com/BloodHoundAD/SharpHound/blob/dev/src/Runtime/ObjectProcessors.cs\n\nGPOLocalGroup\n\nFaced with the limitations of SAMR, we will look at the second way SharpHound gathers user rights, the GPOLocalGroup collection method.\n\nHow does it work?\n\nGroup Policy Objects (GPOs) can be used to manage local groups on computers. This can be done in two different ways and both are collected by SharpHound:\n\nLocal Users and Groups Group Policy Preferences (GPP) found at Computer Configuration\\Preferences\\Control Panel Settings\\(Despite the fact that this can also be managed in User Configuration, SharpHound will only look at the Computer Configuration part)\nRestricted Groups found at Computer Configuration\\Policies\\Windows Settings\\Security Settings\\\nImplementation details\n\nThe data collection goes as follows:\n\nList all OUs that have a GPO linked (gpLink attribute in LDAP)\nSkip gpLink that contains no computer object, or are disabled\nProcess the gPCFileSysPath attribute of each linked GPO object (this attribute specifies where on SYSVOL the files containing the rules are stored)\nSearch for Groups.xml (for Local Users and Groups) and GptTmpl.inf (for Restricted Groups) in all gPCFileSysPath\nFilter for SID we’re interested in:\nAdministrators (S-1-5-32-544…..)\nRemote Desktop Users (S-1-5-32-555…..)\nRemote Management Users (S-1-5-32-580…..)\nDistributed COM Users (S-1-5-32-562…..)\nResolve what domain users belong to these groups and which computers these GPOs are applied to.\n\nThere is more going on that we won’t explain in detail here. In short: there might be conflicts since both methods could be used simultaneously with different or overlapping membership entries. Users can be deleted, added, updated. Additionally, Restricted Groups have precedence over GPP settings and override them. SharpHound will make sure that everything is taken care of and will return the resultant configuration.\n\nLimitations\n\nFirst and foremost, this collection method will not retrieve group memberships added locally (hence the advantage of the SAMR collection method). The completeness of the gathered data will highly vary from domain to domain as some environments heavily rely on GPO to manage local group memberships and other won’t use them at all.\n\nWireshark trace\n\nA Wireshark trace of a successful SharpHound call allows us to highlight the steps involved:\n\nGet all objects in the domain through LDAP (not all requests are shown above)\nEstablish a SMB connection to the DC (Kerberos authentication)\nConnect to the SYSVOL share and look for the XML files\nClose and logoff\n\nAuthorization is performed at two different places in this trace:\n\nWhen querying data through LDAP\nWhen attempting to open the SYSVOL share and the XML files\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (ldap)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nWhat privileges are required?\n\nBy default, GPOs are readable by all Authenticated Users, which makes this collection method a good candidate for pentesters and attackers. However the Security Filtering of a GPO can be edited to restrict read access:\n\nIf the GPO is only readable by computer objects where they apply, access to the policies on SYSVOL will be denied and SharpHound will be blind.\n\nFurther reading\n\nSharpHound implements “GPOLocalGroup” in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/GPOLocalGroupProcessor.cs.",
    "title": "BloodHound Inner Workings & Limitations – Part 1: User Rights Enumeration Through SAMR & GPOLocalGroup"
}
{
    "brief": "In this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations... SharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge... This method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3... The registry can be accessed over the network if the Remote Registry service is running:.. We are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a... However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user... If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it... This is exactly how SharpHound can enumerate who is logged in on the machine:.. To be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can...",
    "html_url": "https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/",
    "text": "BloodHound is the way to go to for finding attack paths in an Active Directory (AD) environment. However, it is not always clear how the data is gathered without looking at the code of SharpHound, the data ingestor for BloodHound.\n\nMicrosoft hardened their systems over time through updates, which makes enumeration of Active Directory (AD) objects and relationships harder than it used to be a couple of years ago.\n\nIn this series of articles, we deep dive into the enumeration methods of SharpHound and their limitations.\n\nTable of Contents\n\nIn this article, we’ll cover session enumeration through Remote Registry and summarize all our findings. Further articles in this series:\n\nUser Rights Enumeration Through SAMR & GPOLocalGroup\nSession Enumeration Through NetWkstaUserEnum & NetSessionEnum\nSession Enumeration (continued)\n\nInformation that proves to be useful during penetration tests is “Who is logged in on which system?”.\n\nSharpHound will try to enumerate this information and BloodHound displays it with a HasSession Edge.\n\nThere are three methods how SharpHound acquires this data:\n\nNetWkstaUserEnum\nNetSessionEnum\nRemote Registry\n\nWe covered the two first in the previous post and the last one will be covered here.\n\nRemote Registry\n\nWhen using the collection method LoggedOn, not only NetWkstaUserEnum is used, the Windows registry of the target is also queried remotely.\n\nThis method was present in SharpHound 2 (the PowerShell one) and later in SharpHound 3. But it was disabled at some point, because it was believed to not deliver the right information. It got re-introduced in the newest SharpHound release again and will (hopefully) stay there.\n\nThis technique is not entirely new, Sysinternals PsLoggedOn and nmap scripts use the same approach.\n\nHow does it work?\n\nThis works by connecting to a named pipe \\PIPE\\winreg, which is exposed via the IPC$ (inter-process communication) SMB share. Then, it uses the Windows Remote Registry Protocol (RPC over SMB on port 445).\n\nRemote Registry Service\n\nLet’s start with the basics. The registry can be accessed over the network if the Remote Registry service is running:\n\nThe default behavior depends on the system:\n\nOS version\tStartup Type\nWindows 8.1\tDisabled\nWindows 10 1809\tDisabled\nWindows 10 21H1\tDisabled\nWindows Server 2012 R2\tAutomatic (Trigger)\nWindows Server 2016 (1607)\tAutomatic (Trigger)\nWindows Server 2019 (1809)\tAutomatic (Trigger)\n Windows Server 2022 (21H2)\tAutomatic (Trigger)\n\nThe service is disabled by default on clients (starting with Windows 8) and enabled on servers (no difference between a DC and a member server). You might find the service running on clients for other reasons:\n\nSome remote administration tools require it for remote management\nVulnerability scanners use it to access the registry remotely\n\nNow, if it’s running automatically, why is the service not started on your server?\n\nAs a matter of fact, the service will stop after 10 minutes of idling to not waste resources. This behavior is controlled by the following registry (!) key:\n\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\RemoteRegistry\nREG_DWORD DisableIdleStop\n1=It will stop after 10min idle\n0=It won't stop when idle\nService Triggers\n\nTo be able to enumerate sessions we need the service to be started. So let’s take a closer look on the defined trigger of the Remote Registry service:\n\n> sc.exe qtriggerinfo RemoteRegistry\n[SC] QueryServiceConfig2 SUCCESS\n\nSERVICE_NAME: RemoteRegistry\n\n        START SERVICE\n          NETWORK EVENT                : 1f81d131-3fac-4537-9e0c-7e7b0c2f4b55 [NAMED PIPE EVENT]\n            DATA                       : winreg\n\nThe trigger is a NAMED PIPE EVENT with the name winreg, it is defined as follows:\n\n> sc.exe triggerinfo\n[CUT]\n        start/namedpipe/pipename        <Start the service when a request\n                                        arrives for the specified named pipe.\n                                        Do not include the \"\\\\.\\pipe\\\" portion\n                                        of the pipe's name>\nWireshark trace\n\nWe can see such a trigger in action live using Wireshark. Here we see the named pipe being called, which will automatically spin up the service once received:\n\nEstablish an SMB connection to the remote host (Kerberos authentication)\nConnect to the IPC$ share\nOpen the winreg named pipe (this is similar to opening a file with that name)\nBind to the winreg interface with UUID 338cd001-2244-31f1-aaaa-900038001003\nInteract using the Windows Remote Registry Protocol\nClose and logoff\n\nAuthorization is performed at three different places in this trace:\n\nWhen we attempt to open the IPC$ share\nWhen we attempt to open the winreg pipe\nWhen we attempt to execute an RPC call via the pipe\n\nYou can try it for yourself using the following Wireshark filter:\n\n((smb2) || (winreg)|| (dcerpc) || (smb)) && !(smb2.ioctl.function == 0x001401fc)\nDefinition of logged-in users\n\nFor better understanding we establish a Remote Registry session using regedit.exe:\n\nClick on “File” → “Connect Network Registry…”\nEnter target machine\nOnce it is connected, we are presented with the two registry hives HKEY_USERS and HKEY_LOCAL_MACHINE\n\nThe other hives you are used to on your local machine (HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG) are not there since they are only shortcuts to subkeys of HKU or HKLM.\n\nWe are interested in the HKEY_USERS hive, since all logged in users on that machine have their NTUSER.DAT a.k.a. HKEY_CURRENT_USER hive (and classes but we ignore them) loaded:\n\nWhat defines “logged-in”? This includes interactive user sessions, but also accounts like NT AUTHORITY\\SYSTEM, NT AUTHORITY\\NETWORK SERVICE, IIS APPPOOL\\.NET v4.5 Classic, NT SERVICE\\SQLTELEMETRY$SQLEXPRESS, etc. will be shown if they are running something on the target.\n\nFiltering results\n\nSharpHound matches only the SID of user accounts using a regex (domain and local users always start with “S-1-5-21”):\n\nprivate static readonly Regex SidRegex = new(@\"S-1-5-21-[0-9]+-[0-9]+-[0-9]+-[0-9]+$\", RegexOptions.Compiled);\n\nIn all other methods, local user accounts are filtered out. This one here will lead to having local user accounts in the BloodHound graph and could be a bug.\n\nLimitations\n\nThe presence of a users SID is not a 100% reliable indicator that he is logged in at this very moment. This has to be taken with a grain of salt, since the hives might be loaded longer than the user itself is logged in.\n\nOur experience is that hives are removed from the registry as soon as an interactive session is ended. However, when a server runs a scheduled task as a user, under unknown conditions, the hive will stay loaded since the “System” process is having an open handle on the NTUSER.DAT and other files of the said user.\n\nWhat privileges are required?\n\nLet’s see why reading the registry remotely is possible at all. If we take a closer look on the permission on the HKEY_USERS hive, we see that Everyone has “Read” access to it. This is exactly how SharpHound can enumerate who is logged in on the machine:\n\nTo be precise, the content of the actual key cannot be read by anybody, but the list of subkeys of HKEY_USERS can.\n\nWe tested different OS to check if there is a difference in these permissions. All tested versions allow “Everyone” to “Read” the hive:\n\nWindows 8.1\nWindows 10 1809\nWindows 10 21H1\nWindows Server 2012 R2\nWindows Server 2016 (1607)\nWindows Server 2019 (1809)\nWindows Server 2022 (21H2)\n\nThe enumerated SIDs can then be resolved to actual usernames and added to the final output of SharpHound.\n\nFurther reading\n\nMore detailed and technical information about the Windows Remote Registry Protocol: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rrp/0fa3191d-bb79-490a-81bd-54c2601b7a78\n\nSharpHound implements the Remote Registry in “ReadUserSessionsRegistry” method in the CommonLib at: https://github.com/BloodHoundAD/SharpHoundCommon/blob/master/src/CommonLib/Processors/ComputerSessionProcessor.cs.\n\nSummary\n\nNow lets sum up all the learnings in one table:\n\nMethod\tOS\nversion\tAdmin\nneeded\tCollection\nmethod\tBloodHound\nedge\tLocal\nusers\tComplete\n-ness\t–stealth\nSAMR\tWindows 10 1607+\nWindows Server 2016 1607+\tYes\tDirect:\nLocalAdmin\nDCOM\nRDP\nPSRemote\n\nIndirect:\nLocalGroup\nComputerOnly\nDefault\nAll\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tYes\tDirect and indirect:\nreplaced with GPOLocalGroup.\nGroup\nPolicy\t–\tNo\tDirect:\nGPOLocalGroup\n\nIndirect:\nAll\nDCOnly\tAdminTo\nCanRDP\nExecuteDCOM\nCanPSRemote\tNo\tNo\t–\nNetWksta\nUserEnum\tAll\tYes\tDirect:\nLoggedOn\n\nIndirect:\nAll\tHasSession\tNo\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nNetSession\nEnum\tWindows 10 1709+ Windows Server 2019 1809+\tYes\tDirect:\nSession\n\nIndirect:\nDefault\nComputerOnly\nAll\tHasSession\tNo\tNo\tDirect and indirect:\nOnly queries Domain Controllers and fileservers (based on LDAP user profiles path)\nRemote Registry\tWindows Server\tNo\tDirect: LoggedOn\n\nIndirect:\nAll\tHasSession\tYes\tYes\tDirect:\nremoved\n\nIndirect:\nreplaced with GPOLocalGroup\nAcknowledgments\n\nThanks to @_wald0, @CptJesus, @harmj0y and the others for the awesome tool.\n\n@SadProcessor has a great cheatsheet on SharpHound, check it out.",
    "title": "BloodHound Inner Workings & Limitations – Part 3: Session Enumeration Through Remote Registry & Summary"
}
