# Lenovo Update Your Privileges

None

https://blog.compass-security.com/2023/07/lenovo-update-your-privileges/
<blockquote>
None..
</blockquote>

---

# P4wnP1-LTE

None

https://sensepost.com/blog/2023/p4wnp1-lte/
<blockquote>
None..
</blockquote>

---

# Relaying NTLM to MSSQL

None

https://blog.compass-security.com/2023/07/relaying-ntlm-to-mssql/
<blockquote>
None..
</blockquote>

---

# Browsers’ cache smuggling

None

https://sensepost.com/blog/2023/browsers-cache-smuggling/
<blockquote>
None..
</blockquote>

---

# Orange Cyberdefense at Hacker Summer Camp

None

https://sensepost.com/blog/2023/orange-cyberdefense-at-hacker-summer-camp/
<blockquote>
None..
</blockquote>

---

# select * from projectdiscovery join steampipe

None

https://sensepost.com/blog/2023/select-from-projectdiscovery-join-steampipe/
<blockquote>
None..
</blockquote>

---

# Filter-Mute Operation: Investigating EDR Internal Communication

None

https://sensepost.com/blog/2023/filter-mute-operation-investigating-edr-internal-communication/
<blockquote>
For example EDR_Driver.sys could subscribe to the “new process creation” notification service using the Windows API named PsSetCreateProcessNotifyRoutine which then, for each process created by the system, the driver will receive information about it (parent PID, command line, etc) The user double-clicks on malware.exe Windows calls the CreateProcessW API in order to load malware.exe into memory EDR_Driver.sys is notified that malware.exe **will be** spawned... A new process called malware.exe will be started soon.” EDR_process.exe can choose to take action (or not): “Ok I will monitor this process by creating hooks in its ntdll.dll” When malware.exe runs, it calls the Windows API... We could take the piece of code below from ired.team as an example of malware.exe... From Windows kernel memory space, EDR_Driver.sys could use several Windows Kernel API’s (callbacks) to monitor and then block the malicious system activities... Because we only focus on kernel part of EDR, here is a visualisation on what happens when you remove kernel callbacks:.. We won’t go into details on this topic, it’s covered in the blogpost Blinding EDR On Windows from Zach Stein... The first prerequisite for this step is to have a kernel-mode read / write primitive that we can use to set the value to 0... Let’s take a look at how we can get this address!.. This is a bit long for the middle of the blogpost, but if you’re curious and want to know how to do this using Windbg, check out the EXTRA MILE section at the end: “kernel walking, 10 steps to get access to MaxConnections”.. Personally I do this operation using a my own tool (unsigned evil driver) which allows us to kill a process even if it’s protected, but it’s also possible to use Process Hacker (if not denylisted) or even better any exploitable “process killer drivers”... Using this we can test if our “filter-mute technique” could be useful... (HR=0x%08X)\n", hr); if (hr == 0x800704D6) { printf("ERROR_CONNECTION_COUNT_LIMIT : A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.\n"); } } // Other common errors you should check are // ERROR_BAD_PATHNAME (HR=0x800700A1) // E_FILE_NOT_FOUND (HR=0x80070002) // E_ACCESSDENIED (HR=0x80070005) // ERROR_INVALID_NAME (HR=0x8007007B) Static KDP: an EDR driver should call the MmProtectDriverSection API for protecting a section of its image Dynamic KDP: allows a driver to allocate and initialise read-only memory using services provided by a secure pool, which is managed by the secure kernel, using ExAllocatePool3 API... Want to know how to get MaxConnections value?.. The method below shows how to get the MaxConnections value of the driver named bindflt.sys using Windbg... You can get the address directly:.. Step 6 – compute the First filter address (Base of FLTMGR!_FLT_FILTER): 0xffffca0c386e8010.. kd> .formats poi(ffffca0c`3eaf7430).. You got it!.. and.. kd> !process 0 0 MsMpEng.exe PROCESS ffffa40a23a5f340.. Because it was a nightmare for me to visualise where I am in kernel memory, what are the fields of the data structures, the links between data structures, what offsets should I use, etc I made the map below (which also includes Windbg commands)...
</blockquote>

---

